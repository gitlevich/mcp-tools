<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Photo Search</title>
<style>
  :root {
    --bg: #1a1a1a;
    --card: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-dim: #8b949e;
    --blue: #58a6ff;
    --green: #3fb950;
    --amber: #d29922;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  /* Search bar */
  .search-bar {
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  .search-bar h1 {
    font-size: 1.1rem;
    font-weight: 600;
    white-space: nowrap;
  }
  .search-input {
    flex: 1;
    max-width: 600px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    padding: 0.5rem 0.75rem;
    font-size: 0.95rem;
    font-family: inherit;
    outline: none;
    transition: border-color 0.2s;
  }
  .search-input:focus { border-color: var(--blue); }
  .search-input::placeholder { color: var(--text-dim); }
  .search-btn-group {
    position: relative;
    display: flex;
    align-items: stretch;
  }
  .search-btn {
    background: var(--blue);
    color: #000;
    border: none;
    border-radius: 6px 0 0 6px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
  }
  .search-btn:hover { opacity: 0.9; }
  .search-btn:disabled { opacity: 0.5; cursor: wait; }
  .search-btn.notes-only { background: var(--green); }
  .search-opts-toggle {
    background: var(--blue);
    color: #000;
    border: none;
    border-left: 1px solid rgba(0,0,0,0.2);
    border-radius: 0 6px 6px 0;
    padding: 0 0.45rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 0.6rem;
  }
  .search-opts-toggle:hover { opacity: 0.9; }
  .search-opts-toggle.notes-only { background: var(--green); }
  .search-opts-popup {
    display: none;
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.5rem 0.65rem;
    z-index: 25;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    white-space: nowrap;
  }
  .search-opts-popup.visible { display: block; }
  .search-opts-popup label {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: var(--text);
    cursor: pointer;
    padding: 0.2rem 0;
  }
  .search-opts-popup input[type="checkbox"] {
    accent-color: var(--blue);
  }
  .search-opts-popup input#optNotes {
    accent-color: var(--green);
  }
  .search-meta {
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-left: auto;
    white-space: nowrap;
  }

  /* Search history dropdown */
  .search-wrapper {
    position: relative;
    flex: 1;
    max-width: 600px;
  }
  .search-wrapper .search-input {
    max-width: none;
    width: 100%;
    padding-right: 1.8rem;
  }
  .search-clear {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    padding: 4px;
    line-height: 0;
    display: none;
    z-index: 10;
    border-radius: 3px;
  }
  .search-clear:hover { color: var(--text); background: rgba(255,255,255,0.08); }
  .search-dropdown {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    max-height: 360px;
    overflow-y: auto;
    z-index: 20;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  }
  .search-dropdown.visible { display: block; }
  .search-dropdown-section {
    padding: 0.3rem 0.6rem 0.15rem;
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    border-bottom: 1px solid var(--border);
  }
  .search-dropdown-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    cursor: pointer;
    font-size: 0.8rem;
    color: var(--text);
    border-bottom: 1px solid rgba(48,54,61,0.4);
  }
  .search-dropdown-item:last-child { border-bottom: none; }
  .search-dropdown-item:hover { background: rgba(88,166,255,0.08); }
  .search-dropdown-item .item-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .search-dropdown-item .item-action {
    flex-shrink: 0;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    opacity: 0;
    transition: opacity 0.15s;
  }
  .search-dropdown-item:hover .item-action { opacity: 1; }
  .search-dropdown-item .item-action:hover { color: var(--text); background: rgba(255,255,255,0.06); }
  .search-dropdown-item .item-pin {
    flex-shrink: 0;
    width: 14px;
    height: 14px;
    color: var(--blue);
  }

  /* Main content layout */
  .content-area {
    display: flex;
    min-height: calc(100vh - 60px);
  }

  /* Results grid (left / main) */
  .results {
    flex: 1;
    padding: 1.25rem 1.5rem 4rem 2rem;
    min-width: 0;
    transition: flex 0.35s ease, width 0.35s ease, padding 0.35s ease;
  }

  /* Notes sidebar (right) */
  .notes-section {
    display: none;
    width: 280px;
    flex-shrink: 0;
    padding: 0.75rem 1rem 4rem 0;
    border-left: 1px solid var(--border);
    overflow-y: auto;
    max-height: calc(100vh - 60px);
    position: sticky;
    top: 60px;
    transition: width 0.35s ease, flex 0.35s ease, padding 0.35s ease;
  }
  .notes-section.visible { display: block; }

  /* Note-focus mode: photos fold left, notes expand */
  .content-area.note-focus .results {
    flex: 0 0 220px;
    width: 220px;
    padding: 0.75rem 0.5rem 4rem 0.75rem;
    overflow-y: auto;
    max-height: calc(100vh - 60px);
    position: sticky;
    top: 60px;
    border-right: 1px solid var(--border);
  }
  .content-area.note-focus .results .grid {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
  .content-area.note-focus .results .card-info { display: none; }
  .content-area.note-focus .notes-section {
    flex: 1;
    width: auto;
    border-left: none;
    padding: 1.25rem 2rem 4rem 1.5rem;
  }

  /* Note reader overlay */
  .note-reader {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 100;
    background: rgba(0, 0, 0, 0.92);
    justify-content: center;
    align-items: flex-start;
    padding: 3rem 2rem;
    overflow-y: auto;
    cursor: default;
  }
  .note-reader.active { display: flex; }
  .note-reader-content {
    max-width: 700px;
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 2rem 2.5rem;
  }
  .note-reader-path {
    font-size: 0.7rem;
    color: var(--blue);
    margin-bottom: 1rem;
  }
  .note-reader-text {
    font-size: 0.9rem;
    color: var(--text);
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .note-reader-close {
    position: fixed;
    top: 1rem;
    right: 1.5rem;
    background: none;
    border: none;
    color: var(--text-dim);
    font-size: 1.5rem;
    cursor: pointer;
    z-index: 101;
  }
  .note-reader-close:hover { color: var(--text); }

  /* Active note card highlight */
  .note-card.active {
    border-left-color: var(--green);
    background: rgba(63, 185, 80, 0.08);
  }
  .notes-header {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.4rem;
    padding-left: 0.5rem;
  }
  .notes-grid {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .note-card {
    position: relative;
    background: var(--card);
    border: 1px solid var(--border);
    border-left: 2px solid var(--blue);
    border-radius: 4px;
    padding: 0.35rem 0.5rem 1rem;
    cursor: pointer;
  }
  .note-card:hover { border-color: var(--blue); }
  .note-card.expanded .note-card-text {
    max-height: none;
    color: var(--text);
  }
  .note-card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.15rem;
  }
  .note-card-path {
    font-size: 0.6rem;
    color: var(--blue);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .note-card-score {
    font-size: 0.55rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
    flex-shrink: 0;
    margin-left: 0.3rem;
  }
  .note-card-date {
    position: absolute;
    bottom: 0.25rem;
    right: 0.4rem;
    font-size: 0.5rem;
    color: var(--text-dim);
  }
  .note-card-text {
    font-size: 0.65rem;
    color: var(--text-dim);
    line-height: 1.35;
    max-height: 3.5em;
    overflow: hidden;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 1rem;
  }

  /* Image card */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    transition: border-color 0.2s, transform 0.15s;
    cursor: pointer;
  }
  .card-image-wrap { position: relative; }
  .card-badge {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 20px;
    height: 20px;
    background: rgba(63, 185, 80, 0.85);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 2;
  }
  .card-badge.has-tasks { background: rgba(210, 153, 34, 0.9); }
  .card-badge svg {
    width: 12px;
    height: 12px;
    fill: none;
    stroke: #fff;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .card:hover {
    border-color: var(--blue);
    transform: translateY(-2px);
  }
  /* Annotation overlay on hover */
  .card-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.85) 25%);
    padding: 2rem 0.6rem 0.5rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1;
    max-height: 60%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }
  .card:hover .card-overlay { opacity: 1; }
  .card-overlay-scroll {
    overflow-y: auto;
    max-height: 100%;
  }
  .card-overlay-line {
    font-size: 0.7rem;
    color: var(--green);
    padding: 0.1rem 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .card-overlay-line:first-child {
    font-size: 0.75rem;
    white-space: normal;
  }
  .card-overlay-line.task {
    color: var(--amber, #d29922);
    font-style: italic;
  }
  .card-meta-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.6));
    padding: 1.2rem 0.5rem 0.3rem;
    pointer-events: none;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    gap: 0.3rem;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.8);
    z-index: 0;
  }
  .card:hover .card-meta-overlay { opacity: 0; transition: opacity 0.2s; }
  .card-meta-date, .card-meta-location {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .card-meta-location { text-align: right; }
  .card-img {
    width: 100%;
    aspect-ratio: 1;
    object-fit: cover;
    display: block;
    background: #0a0c10;
  }
  .card-info {
    padding: 0.6rem 0.75rem;
    font-size: 0.75rem;
  }
  .card-filename {
    color: var(--text);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 0.25rem;
  }
  .card-scores {
    display: flex;
    gap: 0.5rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
  }
  .card-date {
    color: var(--text-dim);
    font-size: 0.65rem;
    margin-top: 0.15rem;
  }
  .card-annotations {
    margin-top: 0.3rem;
    color: var(--green);
    font-size: 0.7rem;
  }
  /* Glow animation for resolved tasks */
  @keyframes glow {
    0% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.6); }
    50% { box-shadow: 0 0 12px 4px rgba(63, 185, 80, 0.4); }
    100% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0); }
  }
  .card.glow { animation: glow 1.5s ease-out; }

  /* States */
  .empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-dim);
  }
  .empty-state h2 {
    font-size: 1.2rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }
  .empty-state p {
    font-size: 0.85rem;
  }
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--blue);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-right: 0.5rem;
    vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Status panel */
  .status-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 50;
    background: var(--card);
    border-top: 1px solid var(--border);
    transition: transform 0.25s ease;
  }
  .status-panel.collapsed .status-body { display: none; }
  .status-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 2rem;
    cursor: pointer;
    -webkit-user-select: none;
    user-select: none;
    font-size: 0.75rem;
    color: var(--text-dim);
  }
  .status-toggle:hover { color: var(--text); }
  .status-toggle .arrow {
    transition: transform 0.2s;
    font-size: 0.6rem;
  }
  .status-panel.collapsed .status-toggle .arrow { transform: rotate(180deg); }
  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--green);
    flex-shrink: 0;
  }
  .status-dot.busy {
    background: var(--blue);
    animation: pulse 1.2s ease-in-out infinite;
  }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .status-body {
    padding: 0.5rem 2rem 0.75rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
    font-size: 0.75rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
  }
  .status-body .stat-label { color: var(--text-dim); }
  .status-body .stat-value { color: var(--text); font-weight: 500; font-variant-numeric: tabular-nums; }
  .status-folders {
    position: relative;
    max-width: 300px;
  }
  .status-folders .folder-label {
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .folder-tooltip {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 8px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.4rem 0.75rem;
    white-space: nowrap;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    z-index: 60;
  }
  .status-folders:hover .folder-tooltip { display: block; }
  .folder-tooltip div {
    padding: 0.15rem 0;
    font-size: 0.7rem;
    color: var(--text-dim);
  }
  .refresh-btn {
    background: transparent;
    color: var(--blue);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.25rem 0.6rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
    white-space: nowrap;
  }
  .refresh-btn:hover { border-color: var(--blue); }
  .refresh-btn:disabled { opacity: 0.5; cursor: wait; }
  .status-activity {
    color: var(--blue);
    font-style: italic;
  }

  /* Lightbox */
  .lightbox {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 100;
    background: rgba(0, 0, 0, 0.92);
    justify-content: center;
    align-items: center;
    cursor: zoom-out;
  }
  .lightbox.active { display: flex; }
  .lightbox img {
    max-width: 95vw;
    max-height: 95vh;
    object-fit: contain;
    border-radius: 4px;
  }
  .lightbox-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--card);
    border-top: 1px solid var(--border);
    padding: 0.75rem 2rem;
    cursor: default;
  }
  .lightbox-path {
    font-size: 0.75rem;
    color: var(--text-dim);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 0.25rem;
  }
  .lightbox-meta {
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-bottom: 0.5rem;
  }
  .lightbox-meta:empty { display: none; }
  .annotation-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex-wrap: wrap;
    max-height: 5.5rem;
    overflow-y: auto;
  }
  .annotation-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    background: rgba(63, 185, 80, 0.15);
    color: var(--green);
    border: 1px solid rgba(63, 185, 80, 0.3);
    border-radius: 4px;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    cursor: text;
    flex-shrink: 0;
  }
  .annotation-tag .tag-text {
    outline: none;
    min-width: 1ch;
  }
  .annotation-tag .tag-text[contenteditable="true"] {
    background: var(--bg);
    border-radius: 2px;
    padding: 0 0.2rem;
    color: var(--text);
  }
  .annotation-tag.task {
    background: rgba(210, 153, 34, 0.15);
    color: var(--amber);
    border-color: rgba(210, 153, 34, 0.3);
    font-style: italic;
  }
  .annotation-tag .remove-tag {
    cursor: pointer;
    opacity: 0.6;
    font-size: 0.8rem;
    line-height: 1;
    flex-shrink: 0;
  }
  .annotation-tag .remove-tag:hover { opacity: 1; }
  .annotation-input {
    flex: 1;
    min-width: 150px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.25rem 0.5rem;
    font-size: 0.7rem;
    font-family: inherit;
    outline: none;
  }
  .annotation-input:focus { border-color: var(--green); }
  .annotation-input::placeholder { color: var(--text-dim); }
</style>
</head>
<body>

<div class="search-bar">
  <h1>Photo Search</h1>
  <div class="search-wrapper">
    <input
      class="search-input"
      id="query"
      type="text"
      placeholder="Describe what you're looking for..."
      autofocus
      autocomplete="off"
    >
    <button class="search-clear" id="searchClear" type="button" title="Clear"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="3" x2="11" y2="11"/><line x1="11" y1="3" x2="3" y2="11"/></svg></button>
    <div class="search-dropdown" id="searchDropdown"></div>
  </div>
  <div class="search-btn-group">
    <button class="search-btn" id="searchBtn" onclick="doSearch()">Search</button>
    <button class="search-opts-toggle" id="searchOptsToggle" type="button">&#9662;</button>
    <div class="search-opts-popup" id="searchOptsPopup">
      <label><input type="checkbox" id="optPhotos" checked> Photos</label>
      <label><input type="checkbox" id="optNotes" checked> Notes</label>
    </div>
  </div>
  <span class="search-meta" id="searchMeta"></span>
</div>

<div class="content-area">
<div class="results" id="results">
  <div class="empty-state">
    <h2>Search your photos</h2>
    <p>Type a description like "sunset at the beach" or "birthday party"</p>
  </div>
</div>
<div class="notes-section" id="notesSection">
  <div class="notes-header" id="notesHeader">Notes</div>
  <div class="notes-grid" id="notesGrid"></div>
</div>
</div>

<div class="note-reader" id="noteReader" onclick="closeNoteReader(event)">
  <button class="note-reader-close" onclick="closeNoteReader()">&times;</button>
  <div class="note-reader-content" onclick="event.stopPropagation()">
    <div class="note-reader-path" id="noteReaderPath"></div>
    <div class="note-reader-text" id="noteReaderText"></div>
  </div>
</div>

<div class="status-panel collapsed" id="statusPanel">
  <div class="status-toggle" onclick="togglePanel()">
    <span class="arrow">&#9660;</span>
    <span class="status-dot" id="statusDot"></span>
    <span id="statusSummary">Loading...</span>
  </div>
  <div class="status-body">
    <span><span class="stat-label">Images: </span><span class="stat-value" id="statImages">--</span></span>
    <span id="statChunksWrap"><span class="stat-label">Notes: </span><span class="stat-value" id="statChunks">--</span></span>
    <span><span class="stat-label">Models: </span><span class="stat-value" id="statModels">--</span></span>
    <span class="status-folders" id="statFolders"></span>
    <span class="status-activity" id="statActivity"></span>
    <button class="refresh-btn" id="addFolderBtn" onclick="doPickFolder()">Add Folder</button>
    <button class="refresh-btn" id="refreshBtn" onclick="doRefresh()">Refresh</button>
  </div>
</div>

<div class="lightbox" id="lightbox" onclick="closeLightbox(event)">
  <img id="lightboxImg">
  <div class="lightbox-panel" onclick="event.stopPropagation()">
    <div class="lightbox-path" id="lightboxPath"></div>
    <div class="lightbox-meta" id="lightboxMeta"></div>
    <div class="annotation-row" id="annotationRow">
      <input
        class="annotation-input"
        id="annotationInput"
        type="text"
        placeholder="Add annotation... (Enter to save)"
      >
    </div>
  </div>
</div>

<script>
const queryInput = document.getElementById('query');
const searchBtn = document.getElementById('searchBtn');
const searchMeta = document.getElementById('searchMeta');
const searchOptsToggle = document.getElementById('searchOptsToggle');
const searchOptsPopup = document.getElementById('searchOptsPopup');
const optPhotos = document.getElementById('optPhotos');
const optNotes = document.getElementById('optNotes');
const searchClear = document.getElementById('searchClear');

function updateClearBtn() {
  searchClear.style.display = queryInput.value ? 'block' : 'none';
}
queryInput.addEventListener('input', updateClearBtn);
searchClear.addEventListener('click', () => {
  queryInput.value = '';
  updateClearBtn();
  queryInput.focus();
});
updateClearBtn();

const NOTES_PREF_KEY = 'photo-search-notes-enabled';

function loadNotesPref() {
  try { return localStorage.getItem(NOTES_PREF_KEY) !== 'false'; } catch { return true; }
}
function saveNotesPref(on) {
  localStorage.setItem(NOTES_PREF_KEY, on ? 'true' : 'false');
}

optNotes.checked = loadNotesPref();

function notesEnabled() { return optNotes.checked; }

function updateBtnColor() {
  const notesOnly = optNotes.checked && !optPhotos.checked;
  searchBtn.classList.toggle('notes-only', notesOnly);
  searchOptsToggle.classList.toggle('notes-only', notesOnly);
}

function applyNotesVisibility() {
  const on = notesEnabled();
  saveNotesPref(on);
  updateBtnColor();
  if (!on) {
    notesSection.classList.remove('visible');
    contentArea.classList.remove('note-focus');
  }
  document.getElementById('statChunksWrap').style.display = on ? '' : 'none';
}

optPhotos.addEventListener('change', updateBtnColor);
optNotes.addEventListener('change', applyNotesVisibility);

searchOptsToggle.addEventListener('click', (e) => {
  e.stopPropagation();
  searchOptsPopup.classList.toggle('visible');
});
searchOptsPopup.addEventListener('click', (e) => e.stopPropagation());
document.addEventListener('click', () => searchOptsPopup.classList.remove('visible'));
const resultsDiv = document.getElementById('results');
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
const lightboxPath = document.getElementById('lightboxPath');
const annotationRow = document.getElementById('annotationRow');
const annotationInput = document.getElementById('annotationInput');
let _lightboxResult = null;
const PAGE_SIZE = 50;
let _allResults = [];
let _displayedCount = 0;
let _loadingMore = false;

const searchDropdown = document.getElementById('searchDropdown');
const HISTORY_KEY = 'photo-search-history';
const PRESETS_KEY = 'photo-search-presets';
const MAX_HISTORY = 20;

function loadHistory() {
  try { return JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; } catch { return []; }
}
function saveHistoryList(list) {
  localStorage.setItem(HISTORY_KEY, JSON.stringify(list));
}
function pushHistory(query) {
  const list = loadHistory().filter(q => q !== query);
  list.unshift(query);
  if (list.length > MAX_HISTORY) list.length = MAX_HISTORY;
  saveHistoryList(list);
}
function removeHistory(query) {
  saveHistoryList(loadHistory().filter(q => q !== query));
}
function loadPresets() {
  try { return JSON.parse(localStorage.getItem(PRESETS_KEY)) || []; } catch { return []; }
}
function savePresetList(list) {
  localStorage.setItem(PRESETS_KEY, JSON.stringify(list));
}
function addPreset(query) {
  const list = loadPresets();
  if (!list.includes(query)) { list.push(query); savePresetList(list); }
}
function removePreset(query) {
  savePresetList(loadPresets().filter(q => q !== query));
}

function renderDropdown() {
  const presets = loadPresets();
  const history = loadHistory().filter(q => !presets.includes(q));
  if (!presets.length && !history.length) {
    searchDropdown.classList.remove('visible');
    return;
  }
  let html = '';
  if (presets.length) {
    html += '<div class="search-dropdown-section">Presets</div>';
    for (const q of presets) {
      html += `<div class="search-dropdown-item" data-query="${escapeAttr(q)}">`;
      html += `<svg class="item-pin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 17v5"/><path d="M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V5a1 1 0 0 1 1-1 1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1 1 1 0 0 1 1 1z"/></svg>`;
      html += `<span class="item-text">${escapeHtml(q)}</span>`;
      html += `<span class="item-action" data-unpin="${escapeAttr(q)}" title="Remove preset">unpin</span>`;
      html += '</div>';
    }
  }
  if (history.length) {
    html += '<div class="search-dropdown-section">Recent</div>';
    for (const q of history) {
      html += `<div class="search-dropdown-item" data-query="${escapeAttr(q)}">`;
      html += `<span class="item-text">${escapeHtml(q)}</span>`;
      html += `<span class="item-action" data-pin="${escapeAttr(q)}" title="Save as preset">pin</span>`;
      html += `<span class="item-action" data-remove="${escapeAttr(q)}" title="Remove">\u00d7</span>`;
      html += '</div>';
    }
  }
  searchDropdown.innerHTML = html;
  searchDropdown.classList.add('visible');
}

function escapeAttr(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;');
}

function showDropdown() { renderDropdown(); }
function hideDropdown() {
  setTimeout(() => {
    if (!searchDropdown.contains(document.activeElement)) {
      searchDropdown.classList.remove('visible');
    }
  }, 150);
}

searchDropdown.addEventListener('mousedown', (e) => {
  // Prevent blur on input when clicking dropdown
  e.preventDefault();
  const item = e.target.closest('.search-dropdown-item');
  const pinBtn = e.target.closest('[data-pin]');
  const unpinBtn = e.target.closest('[data-unpin]');
  const removeBtn = e.target.closest('[data-remove]');

  if (unpinBtn) {
    removePreset(unpinBtn.dataset.unpin);
    renderDropdown();
    return;
  }
  if (pinBtn) {
    addPreset(pinBtn.dataset.pin);
    renderDropdown();
    return;
  }
  if (removeBtn) {
    removeHistory(removeBtn.dataset.remove);
    renderDropdown();
    return;
  }
  if (item) {
    queryInput.value = item.dataset.query;
    searchDropdown.classList.remove('visible');
    doSearch();
  }
});

queryInput.addEventListener('focus', showDropdown);
queryInput.addEventListener('click', showDropdown);
queryInput.addEventListener('blur', hideDropdown);

queryInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { searchDropdown.classList.remove('visible'); doSearch(); }
  if (e.key === 'Escape') {
    if (searchDropdown.classList.contains('visible')) {
      searchDropdown.classList.remove('visible');
    } else {
      queryInput.value = '';
    }
  }
});

let _selectedCardIndex = -1;

function getCards() {
  return Array.from(document.querySelectorAll('#resultsGrid .card'));
}

function selectCard(index) {
  const cards = getCards();
  if (!cards.length) return;
  // Deselect previous
  if (_selectedCardIndex >= 0 && _selectedCardIndex < cards.length) {
    cards[_selectedCardIndex].style.outline = '';
  }
  _selectedCardIndex = Math.max(0, Math.min(index, cards.length - 1));
  const card = cards[_selectedCardIndex];
  card.style.outline = '2px solid var(--blue)';
  card.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  // Load more if near end
  if (_selectedCardIndex >= _displayedCount - 4 && _displayedCount < _allResults.length) {
    showMore();
    updateSearchMeta(null);
  }
}

function getGridColumns() {
  const grid = document.getElementById('resultsGrid');
  if (!grid) return 1;
  return getComputedStyle(grid).gridTemplateColumns.split(' ').length;
}

document.addEventListener('keydown', (e) => {
  const inInput = document.activeElement === queryInput || document.activeElement === annotationInput;
  const inLightbox = lightbox.classList.contains('active');

  // Escape: close overlays in order
  if (e.key === 'Escape') {
    if (noteReader.classList.contains('active')) {
      noteReader.classList.remove('active');
      return;
    }
    if (inLightbox && !inInput) {
      lightbox.classList.remove('active');
      lightboxImg.src = '';
      _lightboxResult = null;
      return;
    }
    if (contentArea.classList.contains('note-focus') && !inInput) {
      exitNoteFocus();
      return;
    }
  }

  // Skip keyboard nav when typing in inputs
  if (inInput) return;

  // Lightbox arrow navigation
  if (inLightbox) {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      navigateLightbox(-1);
      return;
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      navigateLightbox(1);
      return;
    }
    return;
  }

  // Grid navigation
  const cards = getCards();
  if (!cards.length) return;

  const cols = getGridColumns();

  if (e.key === 'ArrowRight') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex + 1);
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex - 1);
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex + cols);
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex - cols);
  } else if (e.key === 'Enter' && _selectedCardIndex >= 0) {
    e.preventDefault();
    const idx = _selectedCardIndex;
    if (idx < _allResults.length) openLightbox(_allResults[idx]);
  } else if (e.key === ' ') {
    e.preventDefault();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
});

function navigateLightbox(direction) {
  if (!_lightboxResult || !_allResults.length) return;
  const currentIdx = _allResults.findIndex(r => r.path === _lightboxResult.path);
  if (currentIdx < 0) return;
  const newIdx = currentIdx + direction;
  if (newIdx < 0 || newIdx >= _allResults.length) return;
  // Load more results if near the end
  if (newIdx >= _displayedCount - 2 && _displayedCount < _allResults.length) {
    showMore();
    updateSearchMeta(null);
  }
  _selectedCardIndex = newIdx;
  openLightbox(_allResults[newIdx]);
}

const notesSection = document.getElementById('notesSection');
const notesHeader = document.getElementById('notesHeader');
const notesGrid = document.getElementById('notesGrid');

function _formatLocal(utcDate) {
  const d = _DAYS[utcDate.getDay()];
  const mon = _MONTHS[utcDate.getMonth()];
  const day = utcDate.getDate();
  const h = String(utcDate.getHours()).padStart(2, '0');
  const m = String(utcDate.getMinutes()).padStart(2, '0');
  return `${d} ${mon} ${day}, ${h}:${m}`;
}

function extractNoteDate(r) {
  // Try filename: "2026-02-21_0600_name.md"
  const fnMatch = r.rel_path.match(/(\d{4})-(\d{2})-(\d{2})_(\d{2})(\d{2})/);
  if (fnMatch) {
    const [, y, mo, d, h, mi] = fnMatch;
    const utc = new Date(Date.UTC(+y, +mo - 1, +d, +h, +mi));
    return _formatLocal(utc);
  }
  // Try "**Date**: 2026-02-21 06:00 UTC" in text
  const dateMatch = r.text.match(/\*\*Date\*\*:\s*(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})/);
  if (dateMatch) {
    const [, y, mo, d, h, mi] = dateMatch;
    const utc = new Date(Date.UTC(+y, +mo - 1, +d, +h, +mi));
    return _formatLocal(utc);
  }
  // Try "### User (06:00 UTC)" - no full date, show time only
  const tsMatch = r.text.match(/###\s+\w+\s+\((\d{2}):(\d{2})\s*UTC\)/);
  if (tsMatch) {
    const now = new Date();
    const utc = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), +tsMatch[1], +tsMatch[2]));
    return `${String(utc.getHours()).padStart(2, '0')}:${String(utc.getMinutes()).padStart(2, '0')}`;
  }
  return '';
}

function renderNotes(results) {
  notesGrid.innerHTML = '';
  if (!results.length) {
    notesSection.classList.remove('visible');
    return;
  }
  notesHeader.textContent = `Notes (${results.length})`;
  for (const r of results) {
    const card = document.createElement('div');
    card.className = 'note-card';
    const pathLabel = r.rel_path.split('/').slice(-2).join('/');
    const noteDate = extractNoteDate(r);
    card.innerHTML =
      '<div class="note-card-header">' +
        '<span class="note-card-path">' + escapeHtml(pathLabel) + ' :' + r.start_line + '-' + r.end_line + '</span>' +
        '<span class="note-card-score">' + r.score.toFixed(3) + '</span>' +
      '</div>' +
      (noteDate ? '<div class="note-card-date">' + escapeHtml(noteDate) + '</div>' : '') +
      '<div class="note-card-text">' + escapeHtml(r.text) + '</div>';
    card.onclick = () => enterNoteFocus(r, card);
    card.ondblclick = () => openNoteReader(r);
    notesGrid.appendChild(card);
  }
  notesSection.classList.add('visible');
}

const contentArea = document.querySelector('.content-area');
const noteReader = document.getElementById('noteReader');
const noteReaderPath = document.getElementById('noteReaderPath');
const noteReaderText = document.getElementById('noteReaderText');
let _savedQuery = '';

function enterNoteFocus(note, cardEl) {
  // Highlight the active card
  notesGrid.querySelectorAll('.note-card.active').forEach(c => c.classList.remove('active'));
  cardEl.classList.add('active');

  // Expand the card text inline
  notesGrid.querySelectorAll('.note-card.expanded').forEach(c => c.classList.remove('expanded'));
  cardEl.classList.add('expanded');

  // Save current query so we can restore on exit
  if (!contentArea.classList.contains('note-focus')) {
    _savedQuery = queryInput.value;
  }

  // Enter note-focus layout
  contentArea.classList.add('note-focus');

  // Search photos using the note text
  const hdrs = { 'Content-Type': 'application/json' };
  fetch('/search-stream', {
    method: 'POST', headers: hdrs,
    body: JSON.stringify({ query: note.text.trim(), top_k: 200 }),
  }).then(async resp => {
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let idx;
      while ((idx = buffer.indexOf('\n\n')) >= 0) {
        const chunk = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);
        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = JSON.parse(line.slice(6));
          _allResults = data;
          _lastResults = data;
          _displayedCount = 0;
          resultsDiv.innerHTML = '';
          if (data.length) {
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.id = 'resultsGrid';
            resultsDiv.appendChild(grid);
            showMore();
          }
        }
      }
    }
  }).catch(() => {});
}

function exitNoteFocus() {
  contentArea.classList.remove('note-focus');
  notesGrid.querySelectorAll('.note-card.active').forEach(c => c.classList.remove('active'));
  notesGrid.querySelectorAll('.note-card.expanded').forEach(c => c.classList.remove('expanded'));
  if (_savedQuery) {
    queryInput.value = _savedQuery;
    _savedQuery = '';
    doSearch();
  }
}

function openNoteReader(note) {
  const pathLabel = note.rel_path.split('/').slice(-2).join('/');
  noteReaderPath.textContent = pathLabel + ' :' + note.start_line + '-' + note.end_line;
  noteReaderText.textContent = note.text;
  noteReader.classList.add('active');
}

function closeNoteReader(e) {
  if (e && e.target !== noteReader && !e.target.classList.contains('note-reader-close')) return;
  noteReader.classList.remove('active');
}

async function doSearch() {
  const query = queryInput.value.trim();
  if (!query) return;

  pushHistory(query);
  searchBtn.disabled = true;
  searchMeta.innerHTML = '<span class="spinner"></span>Searching...';
  _allResults = [];
  _displayedCount = 0;
  _selectedCardIndex = -1;
  notesSection.classList.remove('visible');

  const hdrs = { 'Content-Type': 'application/json' };
  const t0 = performance.now();

  // Fire thought search independently (if enabled)
  if (optNotes.checked) {
    fetch('/search-thoughts', { method: 'POST', headers: hdrs,
      body: JSON.stringify({ query, top_k: 10 }),
    }).then(r => r.json()).then(renderNotes).catch(() => {});
  } else {
    notesSection.classList.remove('visible');
  }

  if (!optPhotos.checked) {
    if (!optNotes.checked) {
      resultsDiv.innerHTML = '<div class="empty-state"><h2>No search sources selected</h2><p>Enable Photos or Notes in search options</p></div>';
      searchMeta.textContent = '';
    } else {
      resultsDiv.innerHTML = '';
      searchMeta.textContent = '';
    }
    searchBtn.disabled = false;
    return;
  }

  try {
    const resp = await fetch('/search-stream', {
      method: 'POST', headers: hdrs,
      body: JSON.stringify({ query, top_k: 200 }),
    });

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      let idx;
      while ((idx = buffer.indexOf('\n\n')) >= 0) {
        const chunk = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);

        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = JSON.parse(line.slice(6));
          const elapsed = ((performance.now() - t0) / 1000).toFixed(2);

          _allResults = data;
          _lastResults = data;
          _displayedCount = 0;
          _selectedCardIndex = -1;

          resultsDiv.innerHTML = '';
          if (data.length) {
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.id = 'resultsGrid';
            resultsDiv.appendChild(grid);
            showMore();
          }
          updateSearchMeta(elapsed);
        }
      }
    }

    const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
    if (!_allResults.length) {
      resultsDiv.innerHTML = `
        <div class="empty-state">
          <h2>No matching results</h2>
          <p>Try a different description</p>
        </div>`;
      searchMeta.textContent = `0 results (${elapsed}s)`;
    } else {
      updateSearchMeta(elapsed);
    }
  } catch (e) {
    resultsDiv.innerHTML = `
      <div class="empty-state">
        <h2>Search failed</h2>
        <p>${e.message}</p>
      </div>`;
    searchMeta.textContent = 'Error';
  } finally {
    searchBtn.disabled = false;
  }
}

function showMore() {
  const grid = document.getElementById('resultsGrid');
  if (!grid || _displayedCount >= _allResults.length) return;
  const end = Math.min(_displayedCount + PAGE_SIZE, _allResults.length);
  const slice = _allResults.slice(_displayedCount, end);
  appendCards(grid, slice);
  _displayedCount = end;
}

function updateSearchMeta(elapsed) {
  const total = _allResults.length;
  const shown = _displayedCount;
  if (shown < total) {
    searchMeta.textContent = `${shown} of ${total} results` + (elapsed ? ` (${elapsed}s)` : '');
  } else {
    searchMeta.textContent = `${total} results` + (elapsed ? ` (${elapsed}s)` : '');
  }
}

function thumbUrl(previewPath) {
  // preview_thumbnail is like "/path/to/.cache/photo-embed/thumbnails/preview/abc123.webp"
  // extract the filename and serve via /thumbnails/
  const parts = previewPath.split('/');
  return '/thumbnails/' + parts[parts.length - 1];
}

function filename(path) {
  const parts = path.split('/');
  return parts[parts.length - 1];
}

const _MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const _DAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
function formatDate(exifDate) {
  // EXIF format: "2023:07:15 14:30:00" -> "Sat Jul 15, 14:30"
  if (!exifDate) return '';
  const m = exifDate.match(/(\d{4}):(\d{2}):(\d{2})\s+(\d{2}):(\d{2})/);
  if (!m) {
    const parts = exifDate.split(':');
    if (parts.length >= 2) {
      const mon = parseInt(parts[1], 10);
      if (mon >= 1 && mon <= 12) return `${_MONTHS[mon - 1]} ${parts[0]}`;
    }
    return exifDate;
  }
  const dt = new Date(+m[1], +m[2] - 1, +m[3], +m[4], +m[5]);
  const day = _DAYS[dt.getDay()];
  const mon = _MONTHS[dt.getMonth()];
  return `${day} ${mon} ${dt.getDate()}, ${m[4]}:${m[5]}`;
}

function formatDateShort(exifDate) {
  // Compact format for overlay: "Jul 15, 2023"
  if (!exifDate) return '';
  const m = exifDate.match(/(\d{4}):(\d{2}):(\d{2})/);
  if (!m) return '';
  return `${_MONTHS[+m[2] - 1]} ${+m[3]}, ${m[1]}`;
}

function appendCards(grid, results) {
  for (const r of results) {
    const card = document.createElement('div');
    card.className = 'card';
    card.onclick = () => openLightbox(r);

    const scores = Object.entries(r.model_scores)
      .map(([m, s]) => `${m.replace(/-vit.*/, '')}: ${s.toFixed(3)}`)
      .join(' | ');

    const anns = r.annotations || [];
    const hasTasks = anns.some(a => a.startsWith('@task '));
    const hasNotes = anns.length > 0;
    let html = '<div class="card-image-wrap">';
    if (hasNotes) {
      const cls = hasTasks ? 'card-badge has-tasks' : 'card-badge';
      html += `<div class="${cls}"><svg viewBox="0 0 24 24"><path d="M12 20h9M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg></div>`;
      html += '<div class="card-overlay"><div class="card-overlay-scroll">';
      for (const a of anns) {
        const isTask = a.startsWith('@task ');
        html += `<div class="card-overlay-line${isTask ? ' task' : ''}">${escapeHtml(a)}</div>`;
      }
      html += '</div></div>';
    }
    html += `<img class="card-img" src="${thumbUrl(r.preview_thumbnail)}" loading="lazy" alt="">`;
    if (r.date_taken || r.location) {
      html += '<div class="card-meta-overlay">';
      if (r.date_taken) html += `<span class="card-meta-date">${formatDateShort(r.date_taken)}</span>`;
      if (r.location) html += `<span class="card-meta-location">${escapeHtml(r.location)}</span>`;
      html += '</div>';
    }
    html += '</div>';
    html += '<div class="card-info">';
    html += `<div class="card-filename" title="${r.path}">${filename(r.path)}</div>`;
    html += `<div class="card-scores">${scores}</div>`;
    html += '</div>';

    card.innerHTML = html;
    grid.appendChild(card);
  }
}

function openLightbox(result) {
  _lightboxResult = result;
  lightboxImg.src = thumbUrl(result.preview_thumbnail);
  lightboxPath.textContent = result.path;
  const metaParts = [];
  if (result.date_taken) metaParts.push(formatDate(result.date_taken));
  if (result.location) metaParts.push(result.location);
  document.getElementById('lightboxMeta').textContent = metaParts.join(' \u2014 ');
  lightbox.classList.add('active');
  annotationInput.value = '';
  loadAnnotations(result.path);
  if (notesEnabled()) searchNotesForImage(result);
}

function searchNotesForImage(result) {
  // Build a query from the image's annotations and filename
  const anns = (result.annotations || []).filter(a => !a.startsWith('@task '));
  const name = filename(result.path).replace(/\.[^.]+$/, '').replace(/[-_]/g, ' ');
  const query = anns.length ? anns.join(' ') : name;
  const hdrs = { 'Content-Type': 'application/json' };
  fetch('/search-thoughts', { method: 'POST', headers: hdrs,
    body: JSON.stringify({ query, top_k: 10 }),
  }).then(r => r.json()).then(renderNotes).catch(() => {});
}

function closeLightbox(e) {
  if (e && e.target !== lightbox) return;
  lightbox.classList.remove('active');
  lightboxImg.src = '';
  _lightboxResult = null;
}

function renderAnnotationTags(annotations) {
  annotationRow.querySelectorAll('.annotation-tag').forEach(t => t.remove());
  for (const text of annotations) {
    const tag = document.createElement('span');
    tag.className = text.startsWith('@task ') ? 'annotation-tag task' : 'annotation-tag';

    const span = document.createElement('span');
    span.className = 'tag-text';
    span.textContent = text;
    span.onclick = (e) => { e.stopPropagation(); startEditTag(span, text); };

    const x = document.createElement('span');
    x.className = 'remove-tag';
    x.title = 'Remove';
    x.textContent = '\u00d7';
    x.onclick = (e) => { e.stopPropagation(); removeAnnotation(text); };

    tag.appendChild(span);
    tag.appendChild(x);
    annotationRow.insertBefore(tag, annotationInput);
  }
}

function startEditTag(span, originalText) {
  span.contentEditable = 'true';
  span.focus();
  // Select all text
  const range = document.createRange();
  range.selectNodeContents(span);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);

  function commit() {
    span.contentEditable = 'false';
    const newText = span.textContent.trim();
    span.removeEventListener('keydown', onKey);
    span.removeEventListener('blur', onBlur);
    if (!newText || newText === originalText) {
      span.textContent = originalText;
      return;
    }
    editAnnotation(originalText, newText);
  }
  function cancel() {
    span.contentEditable = 'false';
    span.textContent = originalText;
    span.removeEventListener('keydown', onKey);
    span.removeEventListener('blur', onBlur);
  }
  function onKey(e) {
    e.stopPropagation();
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  }
  function onBlur() { commit(); }
  span.addEventListener('keydown', onKey);
  span.addEventListener('blur', onBlur);
}

function escapeHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

async function loadAnnotations(path) {
  try {
    const resp = await fetch('/annotations?path=' + encodeURIComponent(path));
    const annotations = await resp.json();
    renderAnnotationTags(annotations);
  } catch { /* ignore */ }
}

async function addAnnotation(text) {
  if (!_lightboxResult || !text.trim()) return;
  try {
    await fetch('/annotate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: text.trim() }),
    });
    annotationInput.value = '';
    loadAnnotations(_lightboxResult.path);
    // Update the result object so the card shows it too
    if (!_lightboxResult.annotations.includes(text.trim())) {
      _lightboxResult.annotations.push(text.trim());
      updateCardAnnotations(_lightboxResult);
    }
  } catch { /* ignore */ }
}

async function editAnnotation(oldText, newText) {
  if (!_lightboxResult) return;
  try {
    await fetch('/remove-annotation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: oldText }),
    });
    await fetch('/annotate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: newText }),
    });
    _lightboxResult.annotations = _lightboxResult.annotations.map(a => a === oldText ? newText : a);
    updateCardAnnotations(_lightboxResult);
    loadAnnotations(_lightboxResult.path);
  } catch { /* ignore */ }
}

async function removeAnnotation(text) {
  if (!_lightboxResult) return;
  try {
    await fetch('/remove-annotation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text }),
    });
    loadAnnotations(_lightboxResult.path);
    _lightboxResult.annotations = _lightboxResult.annotations.filter(a => a !== text);
    updateCardAnnotations(_lightboxResult);
  } catch { /* ignore */ }
}

function updateCardAnnotations(result, shouldGlow) {
  const cards = document.querySelectorAll('.card');
  for (const card of cards) {
    const fn = card.querySelector('.card-filename');
    if (fn && fn.title === result.path) {
      const wrap = card.querySelector('.card-image-wrap');
      const anns = result.annotations || [];
      const hasTasks = anns.some(a => a.startsWith('@task '));
      let badge = wrap.querySelector('.card-badge');
      let overlay = wrap.querySelector('.card-overlay');

      if (anns.length) {
        // Badge
        if (!badge) {
          badge = document.createElement('div');
          badge.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 20h9M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>';
          wrap.insertBefore(badge, wrap.firstChild);
        }
        badge.className = hasTasks ? 'card-badge has-tasks' : 'card-badge';

        // Overlay
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'card-overlay';
          wrap.insertBefore(overlay, wrap.querySelector('.card-img'));
        }
        let oh = '<div class="card-overlay-scroll">';
        for (const a of anns) {
          const isTask = a.startsWith('@task ');
          oh += `<div class="card-overlay-line${isTask ? ' task' : ''}">${escapeHtml(a)}</div>`;
        }
        oh += '</div>';
        overlay.innerHTML = oh;
      } else {
        if (badge) badge.remove();
        if (overlay) overlay.remove();
      }

      if (shouldGlow) {
        card.classList.remove('glow');
        void card.offsetWidth; // force reflow to restart animation
        card.classList.add('glow');
        setTimeout(() => card.classList.remove('glow'), 1600);
      }
      break;
    }
  }
}

annotationInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.stopPropagation();
    addAnnotation(annotationInput.value);
  }
  if (e.key === 'Escape') {
    e.stopPropagation();
    closeLightbox();
  }
});

// --- Task polling (detect resolved tasks, trigger glow) ---

let _lastResults = []; // current search results for task polling

async function pollTasks() {
  if (!_lastResults.length) return;
  // Only poll cards that have tasks
  const taskResults = _lastResults.filter(r => r.annotations && r.annotations.some(a => a.startsWith('@task ')));
  for (const r of taskResults) {
    try {
      const resp = await fetch('/annotations?path=' + encodeURIComponent(r.path));
      const fresh = await resp.json();
      const oldTasks = r.annotations.filter(a => a.startsWith('@task '));
      const newTasks = fresh.filter(a => a.startsWith('@task '));
      if (newTasks.length < oldTasks.length) {
        // A task was resolved
        r.annotations = fresh;
        updateCardAnnotations(r, true);
        // Update lightbox if open on this image
        if (_lightboxResult && _lightboxResult.path === r.path) {
          _lightboxResult.annotations = fresh;
          renderAnnotationTags(fresh);
        }
      } else if (JSON.stringify(r.annotations.sort()) !== JSON.stringify(fresh.sort())) {
        r.annotations = fresh;
        updateCardAnnotations(r, false);
      }
    } catch { /* ignore */ }
  }
}

setInterval(pollTasks, 3000);

// --- Status panel ---

const statusPanel = document.getElementById('statusPanel');
const statusDot = document.getElementById('statusDot');
const statusSummary = document.getElementById('statusSummary');
const statImages = document.getElementById('statImages');
const statChunks = document.getElementById('statChunks');
const statModels = document.getElementById('statModels');
const statFolders = document.getElementById('statFolders');
const statActivity = document.getElementById('statActivity');
const refreshBtn = document.getElementById('refreshBtn');

let _refreshing = false;

function togglePanel() {
  statusPanel.classList.toggle('collapsed');
}

function folderName(path) {
  const parts = path.split('/');
  return parts[parts.length - 1] || parts[parts.length - 2];
}

async function pollStatus() {
  try {
    const promises = [fetch('/status')];
    if (notesEnabled()) promises.push(fetch('/thought-status').catch(() => null));
    const [resp, thoughtResp = null] = await Promise.all(promises);
    const s = await resp.json();
    const ts = thoughtResp ? await thoughtResp.json().catch(() => ({})) : {};
    const n = s.total_images || 0;
    const chunks = ts.total_chunks || 0;
    statChunks.textContent = chunks.toLocaleString();
    const models = (s.enabled_models || []).map(m => m.replace(/-vit.*/, '')).join(', ');
    const folders = (s.folders || []).map(folderName);
    if (s.photos_library) folders.push('Photos Library');

    statImages.textContent = n.toLocaleString();
    statModels.textContent = models || '--';
    const fullPaths = [...(s.folders || [])];
    if (s.photos_library) fullPaths.push(s.photos_library);
    const folderDisplay = folders.length ? folders.join(', ') : 'No folders';
    statFolders.innerHTML = '<span class="folder-label">' + escapeHtml(folderDisplay) + '</span>'
      + (fullPaths.length ? '<div class="folder-tooltip">' + fullPaths.map(p => '<div>' + escapeHtml(p) + '</div>').join('') + '</div>' : '');

    const act = s.activity;
    if (act) {
      statusDot.classList.add('busy');
      const p = act.progress;
      if (p && p.total > 0) {
        const pct = Math.round(100 * p.current / p.total);
        const rate = p.detail || '';
        statusSummary.textContent = `${p.current.toLocaleString()} of ${p.total.toLocaleString()} images (${pct}%)`;
        statActivity.textContent = rate ? `${act.operation}  ${rate}` : act.operation;
      } else {
        statusSummary.textContent = `${n.toLocaleString()} images  ${act.operation}...`;
        statActivity.textContent = act.operation;
      }
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'Busy';
    } else if (_refreshing) {
      statusDot.classList.add('busy');
      statusSummary.textContent = `${n.toLocaleString()} images  refreshing...`;
    } else {
      statusDot.classList.remove('busy');
      statusSummary.textContent = `${n.toLocaleString()} images`;
      statActivity.textContent = '';
      refreshBtn.disabled = false;
      refreshBtn.textContent = 'Refresh';
    }
  } catch {
    statusDot.classList.remove('busy');
    statusSummary.textContent = 'Service unavailable';
  }
}

async function doPickFolder() {
  const btn = document.getElementById('addFolderBtn');
  btn.disabled = true;
  btn.textContent = 'Selecting...';
  try {
    const resp = await fetch('/pick-folder', { method: 'POST' });
    const msg = await resp.text();
    statActivity.textContent = msg;
    setTimeout(() => { if (statActivity.textContent === msg) statActivity.textContent = ''; }, 5000);
    pollStatus();
  } catch {
    statActivity.textContent = 'Picker failed';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Add Folder';
  }
}

async function doRefresh() {
  if (_refreshing) return;
  _refreshing = true;
  refreshBtn.disabled = true;
  refreshBtn.textContent = 'Refreshing...';
  statActivity.textContent = 'Scanning for new photos...';
  statusDot.classList.add('busy');

  try {
    // Refresh photo-embed (and thought-index if notes enabled)
    const promises = [fetch('/refresh', { method: 'POST' })];
    if (notesEnabled()) promises.push(fetch('/search-thoughts-reindex', { method: 'POST' }).catch(() => null));
    const [photoResp, thoughtResp = null] = await Promise.all(promises);
    const stats = await photoResp.json();
    const parts = [];
    if (stats.new) parts.push(`+${stats.new} new`);
    if (stats.changed) parts.push(`~${stats.changed} changed`);
    if (stats.deleted) parts.push(`-${stats.deleted} deleted`);

    if (thoughtResp) {
      const ts = await thoughtResp.json().catch(() => null);
      if (ts && ts.total_chunks != null) {
        parts.push(`${ts.total_chunks} notes`);
      }
    }

    statActivity.textContent = parts.length
      ? parts.join(', ')
      : 'Up to date';
    setTimeout(() => { if (!_refreshing) statActivity.textContent = ''; }, 5000);
  } catch (e) {
    statActivity.textContent = 'Refresh failed';
  } finally {
    _refreshing = false;
    refreshBtn.disabled = false;
    refreshBtn.textContent = 'Refresh';
    pollStatus();
  }
}

applyNotesVisibility();
pollStatus();
setInterval(pollStatus, 5000);

// Infinite scroll
window.addEventListener('scroll', () => {
  if (_loadingMore || _displayedCount >= _allResults.length) return;
  const scrollBottom = window.innerHeight + window.scrollY;
  if (scrollBottom >= document.body.offsetHeight - 400) {
    _loadingMore = true;
    showMore();
    updateSearchMeta(null);
    _loadingMore = false;
  }
});
</script>
</body>
</html>
