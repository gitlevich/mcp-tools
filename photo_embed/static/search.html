<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Photo Search</title>
<style>
  :root {
    --bg: #1a1a1a;
    --card: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-dim: #8b949e;
    --blue: #58a6ff;
    --green: #3fb950;
    --amber: #d29922;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  /* Search bar */
  .search-bar {
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  .search-bar h1 {
    font-size: 1.1rem;
    font-weight: 600;
    white-space: nowrap;
  }
  .search-input {
    flex: 1;
    max-width: 600px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    padding: 0.5rem 0.75rem;
    font-size: 0.95rem;
    font-family: inherit;
    outline: none;
    transition: border-color 0.2s;
  }
  .search-input:focus { border-color: var(--blue); }
  .search-input::placeholder { color: var(--text-dim); }
  .search-btn-group {
    position: relative;
    display: flex;
    align-items: stretch;
  }
  .search-btn {
    background: var(--blue);
    color: #000;
    border: none;
    border-radius: 6px 0 0 6px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
  }
  .search-btn:hover { opacity: 0.9; }
  .search-btn:disabled { opacity: 0.5; cursor: wait; }
  .search-btn.notes-only { background: var(--green); }
  .search-opts-toggle {
    background: var(--blue);
    color: #000;
    border: none;
    border-left: 1px solid rgba(0,0,0,0.2);
    border-radius: 0 6px 6px 0;
    padding: 0 0.45rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 0.6rem;
  }
  .search-opts-toggle:hover { opacity: 0.9; }
  .search-opts-toggle.notes-only { background: var(--green); }
  .search-opts-popup {
    display: none;
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.5rem 0.65rem;
    z-index: 25;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    white-space: nowrap;
  }
  .search-opts-popup.visible { display: block; }
  .search-opts-popup label {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: var(--text);
    cursor: pointer;
    padding: 0.2rem 0;
  }
  .search-opts-popup input[type="checkbox"] {
    accent-color: var(--blue);
  }
  .search-opts-popup input#optNotes {
    accent-color: var(--green);
  }
  .search-opts-popup .threshold-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: var(--text);
    padding: 0.3rem 0 0.1rem;
    border-top: 1px solid var(--border);
    margin-top: 0.3rem;
  }
  .search-opts-popup .threshold-row input[type="range"] {
    width: 80px;
    accent-color: var(--blue);
  }
  .search-opts-popup .threshold-val {
    min-width: 2rem;
    text-align: right;
    color: var(--text-dim);
  }
  .search-meta {
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-left: auto;
    white-space: nowrap;
  }

  /* Search history dropdown */
  .search-wrapper {
    position: relative;
    flex: 1;
    max-width: 600px;
  }
  .search-wrapper .search-input {
    max-width: none;
    width: 100%;
    padding-right: 1.8rem;
  }
  .search-clear {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    padding: 4px;
    line-height: 0;
    display: none;
    z-index: 10;
    border-radius: 3px;
  }
  .search-clear:hover { color: var(--text); background: rgba(255,255,255,0.08); }
  .search-dropdown {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    max-height: 360px;
    overflow-y: auto;
    z-index: 20;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  }
  .search-dropdown.visible { display: block; }
  .search-dropdown-section {
    padding: 0.3rem 0.6rem 0.15rem;
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    border-bottom: 1px solid var(--border);
  }
  .search-dropdown-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    cursor: pointer;
    font-size: 0.8rem;
    color: var(--text);
    border-bottom: 1px solid rgba(48,54,61,0.4);
  }
  .search-dropdown-item:last-child { border-bottom: none; }
  .search-dropdown-item:hover { background: rgba(88,166,255,0.08); }
  .search-dropdown-item .item-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .search-dropdown-item .item-action {
    flex-shrink: 0;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    opacity: 0;
    transition: opacity 0.15s;
  }
  .search-dropdown-item:hover .item-action { opacity: 1; }
  .search-dropdown-item .item-action:hover { color: var(--text); background: rgba(255,255,255,0.06); }
  .search-dropdown-item .item-pin {
    flex-shrink: 0;
    width: 14px;
    height: 14px;
    color: var(--blue);
  }

  /* Main content layout */
  .content-area {
    display: flex;
    min-height: calc(100vh - 60px);
  }

  /* Results grid (left / main) */
  .results {
    flex: 1;
    padding: 1.25rem 1.5rem 4rem 2rem;
    min-width: 0;
    transition: flex 0.35s ease, width 0.35s ease, padding 0.35s ease;
  }

  /* Notes sidebar (right) */
  .notes-section {
    display: none;
    width: 280px;
    flex-shrink: 0;
    padding: 0.75rem 1rem 4rem 0;
    border-left: 1px solid var(--border);
    overflow-y: auto;
    max-height: calc(100vh - 60px);
    position: sticky;
    top: 60px;
    transition: width 0.35s ease, flex 0.35s ease, padding 0.35s ease;
  }
  .notes-section.visible { display: block; }

  /* Note-focus mode: photos fold left, notes expand */
  .content-area.note-focus .results {
    flex: 0 0 220px;
    width: 220px;
    padding: 0.75rem 0.5rem 4rem 0.75rem;
    overflow-y: auto;
    max-height: calc(100vh - 60px);
    position: sticky;
    top: 60px;
    border-right: 1px solid var(--border);
  }
  .content-area.note-focus .results .grid {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
  .content-area.note-focus .results .card-info { display: none; }
  .content-area.note-focus .notes-section {
    flex: 1;
    width: auto;
    border-left: none;
    padding: 1.25rem 2rem 4rem 1.5rem;
  }

  /* Notes-only mode: photos disabled, notes take full width */
  .content-area.notes-only .results { display: none; }
  .content-area.notes-only .notes-section {
    flex: 1;
    width: auto;
    border-left: none;
    padding: 1.25rem 2rem 4rem 2rem;
  }

  /* Note reader overlay */
  .note-reader {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 100;
    background: rgba(0, 0, 0, 0.92);
    justify-content: center;
    align-items: flex-start;
    padding: 3rem 2rem;
    overflow-y: auto;
    cursor: default;
  }
  .note-reader.active { display: flex; }
  .note-reader-content {
    max-width: 700px;
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 2rem 2.5rem;
  }
  .note-reader-path {
    font-size: 0.7rem;
    color: var(--blue);
    margin-bottom: 1rem;
  }
  .note-reader-text {
    font-size: 0.9rem;
    color: var(--text);
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .note-reader-close {
    position: fixed;
    top: 1rem;
    right: 1.5rem;
    background: none;
    border: none;
    color: var(--text-dim);
    font-size: 1.5rem;
    cursor: pointer;
    z-index: 101;
  }
  .note-reader-close:hover { color: var(--text); }

  /* Active note card highlight */
  .note-card.active {
    border-left-color: var(--green);
    background: rgba(63, 185, 80, 0.08);
  }
  .notes-header {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.4rem;
    padding-left: 0.5rem;
  }
  .notes-grid {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .note-card {
    position: relative;
    background: var(--card);
    border: 1px solid var(--border);
    border-left: 2px solid var(--blue);
    border-radius: 4px;
    padding: 0.35rem 0.5rem 1rem;
    cursor: pointer;
  }
  .note-card:hover { border-color: var(--blue); }
  .note-card.expanded .note-card-text {
    max-height: none;
    color: var(--text);
  }
  .note-card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.15rem;
  }
  .note-card-path {
    font-size: 0.6rem;
    color: var(--blue);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .note-card-score {
    font-size: 0.55rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
    flex-shrink: 0;
    margin-left: 0.3rem;
  }
  .note-card-date {
    position: absolute;
    bottom: 0.25rem;
    right: 0.4rem;
    font-size: 0.5rem;
    color: var(--text-dim);
  }
  .note-card-text {
    font-size: 0.65rem;
    color: var(--text-dim);
    line-height: 1.35;
    max-height: 3.5em;
    overflow: hidden;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 1rem;
  }

  /* Image card */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    transition: border-color 0.2s, transform 0.15s;
    cursor: pointer;
  }
  .card-image-wrap { position: relative; }
  .card-badge {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 20px;
    height: 20px;
    background: rgba(63, 185, 80, 0.85);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 2;
  }
  .card-badge.has-tasks { background: rgba(210, 153, 34, 0.9); }
  .card-badge svg {
    width: 12px;
    height: 12px;
    fill: none;
    stroke: #fff;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .card:hover {
    border-color: var(--blue);
    transform: translateY(-2px);
  }
  /* Annotation overlay on hover */
  .card-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.85) 25%);
    padding: 2rem 0.6rem 0.5rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1;
    max-height: 60%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }
  .card:hover .card-overlay { opacity: 1; }
  .card-overlay-scroll {
    overflow-y: auto;
    max-height: 100%;
  }
  .card-overlay-line {
    font-size: 0.7rem;
    color: var(--green);
    padding: 0.1rem 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .card-overlay-line:first-child {
    font-size: 0.75rem;
    white-space: normal;
  }
  .card-overlay-line.task {
    color: var(--amber, #d29922);
    font-style: italic;
  }
  .card-meta-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.6));
    padding: 1.2rem 0.5rem 0.3rem;
    pointer-events: none;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    gap: 0.3rem;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.8);
    z-index: 0;
  }
  .card:hover .card-meta-overlay { opacity: 0; transition: opacity 0.2s; }
  .card-meta-date, .card-meta-location {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .card-meta-location { text-align: right; }
  .card-img {
    width: 100%;
    aspect-ratio: 1;
    object-fit: cover;
    display: block;
    background: #0a0c10;
  }
  .card-info {
    padding: 0.6rem 0.75rem;
    font-size: 0.75rem;
  }
  .card-filename {
    color: var(--text);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 0.25rem;
  }
  .card-scores {
    display: flex;
    gap: 0.5rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
  }
  .card-date {
    color: var(--text-dim);
    font-size: 0.65rem;
    margin-top: 0.15rem;
  }
  .card-annotations {
    margin-top: 0.3rem;
    color: var(--green);
    font-size: 0.7rem;
  }
  /* Similar button on card hover */
  .card-similar-btn {
    position: absolute;
    top: 6px;
    left: 6px;
    background: rgba(0, 0, 0, 0.7);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 4px;
    padding: 2px 7px;
    font-size: 0.6rem;
    cursor: pointer;
    z-index: 3;
    opacity: 0;
    transition: opacity 0.15s;
    pointer-events: auto;
  }
  .card:hover .card-similar-btn { opacity: 1; }
  .card-similar-btn:hover { background: rgba(88, 166, 255, 0.6); border-color: var(--blue); }

  /* Similar-mode breadcrumb */
  .similar-bar {
    display: none;
    align-items: center;
    gap: 0.6rem;
    padding: 0.5rem 0;
    margin-bottom: 0.75rem;
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  .similar-bar.visible { display: flex; }
  .similar-bar img {
    width: 36px;
    height: 36px;
    object-fit: cover;
    border-radius: 4px;
    border: 1px solid var(--border);
  }
  .similar-bar .similar-label { color: var(--text); font-weight: 500; }
  .similar-bar .similar-back {
    margin-left: auto;
    background: transparent;
    color: var(--blue);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.2rem 0.6rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
  }
  .similar-bar .similar-back:hover { border-color: var(--blue); }

  /* Glow animation for resolved tasks */
  @keyframes glow {
    0% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.6); }
    50% { box-shadow: 0 0 12px 4px rgba(63, 185, 80, 0.4); }
    100% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0); }
  }
  .card.glow { animation: glow 1.5s ease-out; }

  /* States */
  .empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-dim);
  }
  .empty-state h2 {
    font-size: 1.2rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }
  .empty-state p {
    font-size: 0.85rem;
  }
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--blue);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-right: 0.5rem;
    vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Status panel */
  .status-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 50;
    background: var(--card);
    border-top: 1px solid var(--border);
    transition: transform 0.25s ease;
  }
  .status-panel.collapsed .status-body { display: none; }
  .status-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 2rem;
    cursor: pointer;
    -webkit-user-select: none;
    user-select: none;
    font-size: 0.75rem;
    color: var(--text-dim);
  }
  .status-toggle:hover { color: var(--text); }
  .status-toggle .arrow {
    transition: transform 0.2s;
    font-size: 0.6rem;
  }
  .status-panel.collapsed .status-toggle .arrow { transform: rotate(180deg); }
  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--green);
    flex-shrink: 0;
  }
  .status-dot.busy {
    background: var(--blue);
    animation: pulse 1.2s ease-in-out infinite;
  }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .status-body {
    padding: 0.5rem 2rem 0.75rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
    font-size: 0.75rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
  }
  .status-body .stat-label { color: var(--text-dim); }
  .status-body .stat-value { color: var(--text); font-weight: 500; font-variant-numeric: tabular-nums; }
  .status-folders {
    position: relative;
    max-width: 300px;
  }
  .status-folders .folder-label {
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .folder-tooltip {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 8px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.4rem 0.75rem;
    white-space: nowrap;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    z-index: 60;
  }
  .status-folders:hover .folder-tooltip { display: block; }
  .folder-tooltip div {
    padding: 0.15rem 0;
    font-size: 0.7rem;
    color: var(--text-dim);
  }
  .refresh-btn {
    background: transparent;
    color: var(--blue);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.25rem 0.6rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
    white-space: nowrap;
  }
  .refresh-btn:hover { border-color: var(--blue); }
  .refresh-btn:disabled { opacity: 0.5; cursor: wait; }
  .status-activity {
    color: var(--blue);
    font-style: italic;
  }

  /* Entity panel */
  .entity-panel {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 90;
    background: rgba(0, 0, 0, 0.85);
  }
  .entity-panel.open { display: flex; justify-content: center; align-items: flex-start; padding-top: 3rem; }
  .entity-panel-inner {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .entity-panel-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border);
  }
  .entity-panel-header h2 { font-size: 1rem; font-weight: 600; flex: 1; }
  .entity-search-input {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.35rem 0.6rem;
    font-size: 0.85rem;
    font-family: inherit;
    outline: none;
  }
  .entity-search-input:focus { border-color: var(--blue); }
  .entity-type-filter {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.3rem 0.4rem;
    font-size: 0.8rem;
    font-family: inherit;
  }
  .entity-close {
    background: none;
    border: none;
    color: var(--text-dim);
    font-size: 1.4rem;
    cursor: pointer;
    padding: 0 0.3rem;
  }
  .entity-close:hover { color: var(--text); }
  .entity-list {
    overflow-y: auto;
    flex: 1;
    padding: 0.5rem;
  }
  .entity-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
  }
  .entity-item:hover { background: var(--bg); }
  .entity-item.selected { background: #1f3a5f; }
  .entity-item .entity-name { flex: 1; font-weight: 500; }
  .entity-item .entity-type {
    font-size: 0.7rem;
    padding: 0.1rem 0.4rem;
    border-radius: 3px;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .entity-type.person { background: #1a3a2a; color: var(--green); }
  .entity-type.place { background: #3a2a1a; color: var(--amber); }
  .entity-type.org { background: #1a2a3a; color: var(--blue); }
  .entity-item .entity-count { color: var(--text-dim); font-size: 0.75rem; }
  .entity-item .entity-aliases { color: var(--text-dim); font-size: 0.7rem; font-style: italic; }
  .entity-item input[type="checkbox"] { margin-right: 0.2rem; }
  .entity-detail {
    border-top: 1px solid var(--border);
    padding: 0.75rem 1rem;
    max-height: 40vh;
    overflow-y: auto;
  }
  .entity-detail-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
  .entity-detail-header h3 { font-size: 0.95rem; font-weight: 600; }
  .entity-detail-actions { display: flex; gap: 0.4rem; margin-bottom: 0.5rem; }
  .entity-detail-actions button {
    background: transparent;
    color: var(--blue);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
  }
  .entity-detail-actions button:hover { border-color: var(--blue); }
  .entity-detail-actions button.danger { color: #f85149; }
  .entity-detail-actions button.danger:hover { border-color: #f85149; }
  .entity-mention {
    padding: 0.3rem 0;
    border-bottom: 1px solid var(--border);
    font-size: 0.8rem;
  }
  .entity-mention:last-child { border-bottom: none; }
  .entity-mention-path { color: var(--blue); font-size: 0.75rem; }
  .entity-mention-context { color: var(--text-dim); font-size: 0.75rem; margin-top: 0.15rem; }
  .entity-merge-bar {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-top: 1px solid var(--border);
    background: var(--bg);
    font-size: 0.8rem;
  }
  .entity-merge-bar.active { display: flex; }
  .entity-merge-bar button {
    background: var(--blue);
    color: #000;
    border: none;
    border-radius: 4px;
    padding: 0.25rem 0.6rem;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
  }
  .entity-stats-bar {
    display: flex;
    gap: 1rem;
    padding: 0.4rem 1rem;
    border-bottom: 1px solid var(--border);
    font-size: 0.75rem;
    color: var(--text-dim);
  }

  /* Lightbox */
  .lightbox {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 100;
    background: rgba(0, 0, 0, 0.92);
    justify-content: center;
    align-items: center;
    cursor: zoom-out;
  }
  .lightbox.active { display: flex; }
  .lightbox-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--card);
    border-top: 1px solid var(--border);
    padding: 0.75rem 2rem;
    cursor: default;
  }
  .lightbox-path {
    font-size: 0.75rem;
    color: var(--text-dim);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 0.25rem;
  }
  .lightbox-meta {
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-bottom: 0.5rem;
  }
  .lightbox-meta:empty { display: none; }
  .annotation-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex-wrap: wrap;
    max-height: 5.5rem;
    overflow-y: auto;
  }
  .annotation-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    background: rgba(63, 185, 80, 0.15);
    color: var(--green);
    border: 1px solid rgba(63, 185, 80, 0.3);
    border-radius: 4px;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    cursor: text;
    flex-shrink: 0;
  }
  .annotation-tag .tag-text {
    outline: none;
    min-width: 1ch;
  }
  .annotation-tag .tag-text[contenteditable="true"] {
    background: var(--bg);
    border-radius: 2px;
    padding: 0 0.2rem;
    color: var(--text);
  }
  .annotation-tag.task {
    background: rgba(210, 153, 34, 0.15);
    color: var(--amber);
    border-color: rgba(210, 153, 34, 0.3);
    font-style: italic;
  }
  .annotation-tag .remove-tag {
    cursor: pointer;
    opacity: 0.6;
    font-size: 0.8rem;
    line-height: 1;
    flex-shrink: 0;
  }
  .annotation-tag .remove-tag:hover { opacity: 1; }
  .annotation-input {
    flex: 1;
    min-width: 150px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.25rem 0.5rem;
    font-size: 0.7rem;
    font-family: inherit;
    outline: none;
  }
  .annotation-input:focus { border-color: var(--green); }
  .annotation-input::placeholder { color: var(--text-dim); }

  /* Lightbox face overlay */
  .lightbox-image-wrap {
    position: relative;
    display: inline-block;
    max-width: 95vw;
    max-height: 95vh;
  }
  .lightbox-image-wrap img {
    max-width: 95vw;
    max-height: 95vh;
    object-fit: contain;
    border-radius: 4px;
    display: block;
  }
  .face-box {
    position: absolute;
    border: 2px solid var(--blue);
    border-radius: 3px;
    cursor: pointer;
    transition: border-color 0.15s, box-shadow 0.15s;
    z-index: 2;
  }
  .face-box:hover {
    border-color: #fff;
    box-shadow: 0 0 8px rgba(88, 166, 255, 0.6);
  }
  .face-box.labeled {
    border-color: var(--green);
  }
  .face-box.labeled:hover {
    box-shadow: 0 0 8px rgba(63, 185, 80, 0.6);
  }
  .face-box .face-label {
    position: absolute;
    bottom: -18px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: var(--green);
    font-size: 0.6rem;
    padding: 1px 5px;
    border-radius: 3px;
    white-space: nowrap;
    pointer-events: none;
  }

  /* Face context menu */
  .face-menu {
    display: none;
    position: absolute;
    z-index: 110;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.5rem;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    min-width: 180px;
    cursor: default;
  }
  .face-menu.visible { display: block; }
  .face-menu-header {
    font-size: 0.65rem;
    color: var(--text-dim);
    margin-bottom: 0.3rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .face-menu-name {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.3rem 0.5rem;
    font-size: 0.8rem;
    font-family: inherit;
    outline: none;
    margin-bottom: 0.4rem;
  }
  .face-menu-name:focus { border-color: var(--blue); }
  .face-menu-name::placeholder { color: var(--text-dim); }
  .face-menu-actions {
    display: flex;
    gap: 0.3rem;
  }
  .face-menu-btn {
    flex: 1;
    background: transparent;
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.25rem 0.4rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
    text-align: center;
  }
  .face-menu-btn:hover { border-color: var(--blue); color: var(--blue); }
  .face-menu-btn.primary {
    background: var(--blue);
    color: #000;
    border-color: var(--blue);
    font-weight: 500;
  }
  .face-menu-btn.primary:hover { opacity: 0.9; }

  /* Person mode bar */
  .person-bar {
    display: none;
    align-items: center;
    gap: 0.6rem;
    padding: 0.5rem 0;
    margin-bottom: 0.75rem;
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  .person-bar.visible { display: flex; }
  .person-bar img {
    width: 36px;
    height: 36px;
    object-fit: cover;
    border-radius: 4px;
    border: 1px solid var(--border);
  }
  .person-bar .person-name-input {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
    font-family: inherit;
    outline: none;
    width: 120px;
  }
  .person-bar .person-name-input:focus { border-color: var(--blue); }
  .person-bar .person-name-input::placeholder { color: var(--text-dim); }
  .person-bar .person-label { color: var(--text); font-weight: 500; }
  .person-bar .person-count { color: var(--text-dim); font-size: 0.75rem; }
  .person-bar .person-btn {
    background: transparent;
    color: var(--blue);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.2rem 0.6rem;
    font-size: 0.7rem;
    font-family: inherit;
    cursor: pointer;
  }
  .person-bar .person-btn:hover { border-color: var(--blue); }
  .person-bar .person-btn.confirm {
    background: var(--green);
    color: #000;
    border-color: var(--green);
    font-weight: 500;
  }
  .person-bar .person-btn.confirm:hover { opacity: 0.9; }
  .person-bar .person-btn.confirm:disabled { opacity: 0.5; cursor: wait; }

  /* Person mode card checkbox */
  .card-check {
    position: absolute;
    top: 6px;
    left: 6px;
    width: 22px;
    height: 22px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid var(--green);
    border-radius: 4px;
    z-index: 3;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .card-check.checked {
    background: var(--green);
  }
  .card-check svg {
    width: 14px;
    height: 14px;
    fill: none;
    stroke: #fff;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
    display: none;
  }
  .card-check.checked svg { display: block; }
</style>
</head>
<body>

<div class="search-bar">
  <h1>Photo Search</h1>
  <div class="search-wrapper">
    <input
      class="search-input"
      id="query"
      type="text"
      placeholder="Describe what you're looking for..."
      autofocus
      autocomplete="off"
    >
    <button class="search-clear" id="searchClear" type="button" title="Clear"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="3" x2="11" y2="11"/><line x1="11" y1="3" x2="3" y2="11"/></svg></button>
    <div class="search-dropdown" id="searchDropdown"></div>
  </div>
  <div class="search-btn-group">
    <button class="search-btn" id="searchBtn" onclick="doSearch()">Search</button>
    <button class="search-opts-toggle" id="searchOptsToggle" type="button">&#9662;</button>
    <div class="search-opts-popup" id="searchOptsPopup">
      <label><input type="checkbox" id="optPhotos" checked> Photos</label>
      <label><input type="checkbox" id="optNotes" checked> Notes</label>
      <div class="threshold-row">
        <span>Threshold</span>
        <input type="range" id="scoreThreshold" min="0" max="100" step="5" value="60"
               oninput="document.getElementById('thresholdVal').textContent = this.value + '%'; localStorage.setItem('scoreThreshold', this.value)">
        <span class="threshold-val" id="thresholdVal">60%</span>
      </div>
    </div>
  </div>
  <span class="search-meta" id="searchMeta"></span>
</div>

<div class="content-area">
<div class="results" id="results">
  <div class="similar-bar" id="similarBar">
    <img id="similarThumb" src="" alt="">
    <span class="similar-label">Similar to</span>
    <span id="similarName"></span>
    <button class="similar-back" onclick="exitSimilarMode()">Back to results</button>
  </div>
  <div class="person-bar" id="personBar">
    <img id="personThumb" src="" alt="">
    <span class="person-label">Photos of</span>
    <input class="person-name-input" id="personNameInput" type="text" placeholder="Name...">
    <span class="person-count" id="personCount"></span>
    <button class="person-btn confirm" id="personConfirmBtn" onclick="confirmPersonLabels()">Confirm selected</button>
    <button class="person-btn" onclick="exitPersonMode()">Back</button>
  </div>
  <div class="empty-state">
    <h2>Search your photos</h2>
    <p>Type a description like "sunset at the beach" or "birthday party"</p>
  </div>
</div>
<div class="notes-section" id="notesSection">
  <div class="notes-header" id="notesHeader">Notes</div>
  <div class="notes-grid" id="notesGrid"></div>
</div>
</div>

<div class="note-reader" id="noteReader" onclick="closeNoteReader(event)">
  <button class="note-reader-close" onclick="closeNoteReader()">&times;</button>
  <div class="note-reader-content" onclick="event.stopPropagation()">
    <div class="note-reader-path" id="noteReaderPath"></div>
    <div class="note-reader-text" id="noteReaderText"></div>
  </div>
</div>

<div class="entity-panel" id="entityPanel" onclick="closeEntityPanel(event)">
  <div class="entity-panel-inner" onclick="event.stopPropagation()">
    <div class="entity-panel-header">
      <h2>Entities</h2>
      <input class="entity-search-input" id="entitySearchInput" type="text" placeholder="Search entities..." oninput="entitySearchDebounce()">
      <select class="entity-type-filter" id="entityTypeFilter" onchange="loadEntities()">
        <option value="">All types</option>
        <option value="person">People</option>
        <option value="place">Places</option>
        <option value="org">Organizations</option>
      </select>
      <button class="entity-close" onclick="closeEntityPanel()">&times;</button>
    </div>
    <div class="entity-stats-bar" id="entityStatsBar"></div>
    <div class="entity-list" id="entityList"></div>
    <div class="entity-detail" id="entityDetail" style="display:none"></div>
    <div class="entity-merge-bar" id="entityMergeBar">
      <span id="entityMergeInfo">Select 2 entities to merge</span>
      <button onclick="doMergeEntities()">Merge selected</button>
      <button onclick="cancelEntityMerge()" style="background:transparent;color:var(--text-dim);border:1px solid var(--border);">Cancel</button>
    </div>
  </div>
</div>

<div class="status-panel collapsed" id="statusPanel">
  <div class="status-toggle" onclick="togglePanel()">
    <span class="arrow">&#9660;</span>
    <span class="status-dot" id="statusDot"></span>
    <span id="statusSummary">Loading...</span>
  </div>
  <div class="status-body">
    <span><span class="stat-label">Images: </span><span class="stat-value" id="statImages">--</span></span>
    <span id="statFacesWrap"><span class="stat-label">Faces: </span><span class="stat-value" id="statFaces">--</span></span>
    <span id="statChunksWrap"><span class="stat-label">Notes: </span><span class="stat-value" id="statChunks">--</span></span>
    <span><span class="stat-label">Models: </span><span class="stat-value" id="statModels">--</span></span>
    <span id="statCacheWrap"><span class="stat-label">Cache: </span><span class="stat-value" id="statCache">--</span></span>
    <span class="status-folders" id="statFolders"></span>
    <span class="status-activity" id="statActivity"></span>
    <button class="refresh-btn" id="addFolderBtn" onclick="doPickFolder()">Add Folder</button>
    <button class="refresh-btn" id="entitiesBtn" onclick="openEntityPanel()">Entities</button>
    <button class="refresh-btn" id="refreshBtn" onclick="doRefresh()">Refresh</button>
  </div>
</div>

<div class="lightbox" id="lightbox" onclick="closeLightbox(event)">
  <div class="lightbox-image-wrap" id="lightboxWrap" onclick="event.stopPropagation()">
    <img id="lightboxImg" onclick="closeLightbox()">
    <div class="face-menu" id="faceMenu">
      <div class="face-menu-header">Name this person</div>
      <input class="face-menu-name" id="faceMenuName" type="text" placeholder="Name..." autocomplete="off">
      <div class="face-menu-actions">
        <button class="face-menu-btn primary" id="faceMenuLabel" type="button">Label</button>
        <button class="face-menu-btn" id="faceMenuFind" type="button">Find all</button>
      </div>
    </div>
  </div>
  <div class="lightbox-panel" onclick="event.stopPropagation()">
    <div class="lightbox-path" id="lightboxPath"></div>
    <div class="lightbox-meta" id="lightboxMeta"></div>
    <div class="annotation-row" id="annotationRow">
      <input
        class="annotation-input"
        id="annotationInput"
        type="text"
        placeholder="Add annotation... (Enter to save)"
      >
      <button type="button" class="refresh-btn" id="lightboxSimilarBtn" onclick="lightboxFindSimilar()">Similar</button>
    </div>
  </div>
</div>

<script>
const queryInput = document.getElementById('query');
const searchBtn = document.getElementById('searchBtn');
const searchMeta = document.getElementById('searchMeta');
const searchOptsToggle = document.getElementById('searchOptsToggle');
const searchOptsPopup = document.getElementById('searchOptsPopup');
const optPhotos = document.getElementById('optPhotos');
const optNotes = document.getElementById('optNotes');
const searchClear = document.getElementById('searchClear');

function updateClearBtn() {
  searchClear.style.display = queryInput.value ? 'block' : 'none';
}
queryInput.addEventListener('input', updateClearBtn);
searchClear.addEventListener('click', () => {
  queryInput.value = '';
  updateClearBtn();
  queryInput.focus();
});
updateClearBtn();

const NOTES_PREF_KEY = 'photo-search-notes-enabled';

function loadNotesPref() {
  try { return localStorage.getItem(NOTES_PREF_KEY) !== 'false'; } catch { return true; }
}
function saveNotesPref(on) {
  localStorage.setItem(NOTES_PREF_KEY, on ? 'true' : 'false');
}

optNotes.checked = loadNotesPref();

// Restore threshold slider from localStorage
{
  const saved = localStorage.getItem('scoreThreshold');
  if (saved !== null) {
    document.getElementById('scoreThreshold').value = saved;
    document.getElementById('thresholdVal').textContent = saved + '%';
  }
}

function notesEnabled() { return optNotes.checked; }

function updateBtnColor() {
  const notesOnly = optNotes.checked && !optPhotos.checked;
  searchBtn.classList.toggle('notes-only', notesOnly);
  searchOptsToggle.classList.toggle('notes-only', notesOnly);
}

function applyNotesVisibility() {
  const on = notesEnabled();
  saveNotesPref(on);
  updateBtnColor();
  if (!on) {
    notesSection.classList.remove('visible');
    contentArea.classList.remove('note-focus');
    contentArea.classList.remove('notes-only');
  }
  document.getElementById('statChunksWrap').style.display = on ? '' : 'none';
}

optPhotos.addEventListener('change', updateBtnColor);
optNotes.addEventListener('change', applyNotesVisibility);

searchOptsToggle.addEventListener('click', (e) => {
  e.stopPropagation();
  searchOptsPopup.classList.toggle('visible');
});
searchOptsPopup.addEventListener('click', (e) => e.stopPropagation());
document.addEventListener('click', () => searchOptsPopup.classList.remove('visible'));
const resultsDiv = document.getElementById('results');
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
const lightboxPath = document.getElementById('lightboxPath');
const annotationRow = document.getElementById('annotationRow');
const annotationInput = document.getElementById('annotationInput');
let _lightboxResult = null;
const PAGE_SIZE = 50;
let _allResults = [];
let _displayedCount = 0;
let _loadingMore = false;

const searchDropdown = document.getElementById('searchDropdown');
const HISTORY_KEY = 'photo-search-history';
const PRESETS_KEY = 'photo-search-presets';
const MAX_HISTORY = 20;

function loadHistory() {
  try { return JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; } catch { return []; }
}
function saveHistoryList(list) {
  localStorage.setItem(HISTORY_KEY, JSON.stringify(list));
}
function pushHistory(query) {
  const list = loadHistory().filter(q => q !== query);
  list.unshift(query);
  if (list.length > MAX_HISTORY) list.length = MAX_HISTORY;
  saveHistoryList(list);
}
function removeHistory(query) {
  saveHistoryList(loadHistory().filter(q => q !== query));
}
function loadPresets() {
  try { return JSON.parse(localStorage.getItem(PRESETS_KEY)) || []; } catch { return []; }
}
function savePresetList(list) {
  localStorage.setItem(PRESETS_KEY, JSON.stringify(list));
}
function addPreset(query) {
  const list = loadPresets();
  if (!list.includes(query)) { list.push(query); savePresetList(list); }
}
function removePreset(query) {
  savePresetList(loadPresets().filter(q => q !== query));
}

function renderDropdown() {
  const presets = loadPresets();
  const history = loadHistory().filter(q => !presets.includes(q));
  if (!presets.length && !history.length) {
    searchDropdown.classList.remove('visible');
    return;
  }
  let html = '';
  if (presets.length) {
    html += '<div class="search-dropdown-section">Presets</div>';
    for (const q of presets) {
      html += `<div class="search-dropdown-item" data-query="${escapeAttr(q)}">`;
      html += `<svg class="item-pin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 17v5"/><path d="M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V5a1 1 0 0 1 1-1 1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1 1 1 0 0 1 1 1z"/></svg>`;
      html += `<span class="item-text">${escapeHtml(q)}</span>`;
      html += `<span class="item-action" data-unpin="${escapeAttr(q)}" title="Remove preset">unpin</span>`;
      html += '</div>';
    }
  }
  if (history.length) {
    html += '<div class="search-dropdown-section">Recent</div>';
    for (const q of history) {
      html += `<div class="search-dropdown-item" data-query="${escapeAttr(q)}">`;
      html += `<span class="item-text">${escapeHtml(q)}</span>`;
      html += `<span class="item-action" data-pin="${escapeAttr(q)}" title="Save as preset">pin</span>`;
      html += `<span class="item-action" data-remove="${escapeAttr(q)}" title="Remove">\u00d7</span>`;
      html += '</div>';
    }
  }
  searchDropdown.innerHTML = html;
  searchDropdown.classList.add('visible');
}

function escapeAttr(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;');
}

function showDropdown() { renderDropdown(); }
function hideDropdown() {
  setTimeout(() => {
    if (!searchDropdown.contains(document.activeElement)) {
      searchDropdown.classList.remove('visible');
    }
  }, 150);
}

searchDropdown.addEventListener('mousedown', (e) => {
  // Prevent blur on input when clicking dropdown
  e.preventDefault();
  const item = e.target.closest('.search-dropdown-item');
  const pinBtn = e.target.closest('[data-pin]');
  const unpinBtn = e.target.closest('[data-unpin]');
  const removeBtn = e.target.closest('[data-remove]');

  if (unpinBtn) {
    removePreset(unpinBtn.dataset.unpin);
    renderDropdown();
    return;
  }
  if (pinBtn) {
    addPreset(pinBtn.dataset.pin);
    renderDropdown();
    return;
  }
  if (removeBtn) {
    removeHistory(removeBtn.dataset.remove);
    renderDropdown();
    return;
  }
  if (item) {
    queryInput.value = item.dataset.query;
    searchDropdown.classList.remove('visible');
    doSearch();
  }
});

queryInput.addEventListener('focus', showDropdown);
queryInput.addEventListener('click', showDropdown);
queryInput.addEventListener('blur', hideDropdown);

queryInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { searchDropdown.classList.remove('visible'); doSearch(); }
  if (e.key === 'Escape') {
    if (searchDropdown.classList.contains('visible')) {
      searchDropdown.classList.remove('visible');
    } else {
      queryInput.value = '';
    }
  }
});

let _selectedCardIndex = -1;

function getCards() {
  return Array.from(document.querySelectorAll('#resultsGrid .card'));
}

function selectCard(index) {
  const cards = getCards();
  if (!cards.length) return;
  // Deselect previous
  if (_selectedCardIndex >= 0 && _selectedCardIndex < cards.length) {
    cards[_selectedCardIndex].style.outline = '';
  }
  _selectedCardIndex = Math.max(0, Math.min(index, cards.length - 1));
  const card = cards[_selectedCardIndex];
  card.style.outline = '2px solid var(--blue)';
  card.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  // Load more if near end
  if (_selectedCardIndex >= _displayedCount - 4 && _displayedCount < _allResults.length) {
    showMore();
    updateSearchMeta(null);
  }
}

function getGridColumns() {
  const grid = document.getElementById('resultsGrid');
  if (!grid) return 1;
  return getComputedStyle(grid).gridTemplateColumns.split(' ').length;
}

document.addEventListener('keydown', (e) => {
  const inInput = document.activeElement === queryInput || document.activeElement === annotationInput
    || document.activeElement.classList.contains('face-menu-name')
    || document.activeElement.classList.contains('person-name-input');
  const inLightbox = lightbox.classList.contains('active');

  // Escape: close overlays in order
  if (e.key === 'Escape') {
    if (noteReader.classList.contains('active')) {
      noteReader.classList.remove('active');
      return;
    }
    if (inLightbox && !inInput) {
      lightbox.classList.remove('active');
      lightboxImg.src = '';
      _lightboxResult = null;
      return;
    }
    if (contentArea.classList.contains('note-focus') && !inInput) {
      exitNoteFocus();
      return;
    }
  }

  // Skip keyboard nav when typing in inputs
  if (inInput) return;

  // Lightbox arrow navigation
  if (inLightbox) {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      navigateLightbox(-1);
      return;
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      navigateLightbox(1);
      return;
    }
    return;
  }

  // Grid navigation
  const cards = getCards();
  if (!cards.length) return;

  const cols = getGridColumns();

  if (e.key === 'ArrowRight') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex + 1);
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex - 1);
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex + cols);
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    selectCard(_selectedCardIndex < 0 ? 0 : _selectedCardIndex - cols);
  } else if (e.key === 'Enter' && _selectedCardIndex >= 0) {
    e.preventDefault();
    const idx = _selectedCardIndex;
    if (idx < _allResults.length) openLightbox(_allResults[idx]);
  } else if (e.key === ' ') {
    e.preventDefault();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
});

function navigateLightbox(direction) {
  if (!_lightboxResult || !_allResults.length) return;
  const currentIdx = _allResults.findIndex(r => r.path === _lightboxResult.path);
  if (currentIdx < 0) return;
  const newIdx = currentIdx + direction;
  if (newIdx < 0 || newIdx >= _allResults.length) return;
  // Load more results if near the end
  if (newIdx >= _displayedCount - 2 && _displayedCount < _allResults.length) {
    showMore();
    updateSearchMeta(null);
  }
  _selectedCardIndex = newIdx;
  openLightbox(_allResults[newIdx]);
}

const notesSection = document.getElementById('notesSection');
const notesHeader = document.getElementById('notesHeader');
const notesGrid = document.getElementById('notesGrid');

function _formatLocal(utcDate) {
  const d = _DAYS[utcDate.getDay()];
  const mon = _MONTHS[utcDate.getMonth()];
  const day = utcDate.getDate();
  const h = String(utcDate.getHours()).padStart(2, '0');
  const m = String(utcDate.getMinutes()).padStart(2, '0');
  return `${d} ${mon} ${day}, ${h}:${m}`;
}

function extractNoteDate(r) {
  // Try filename: "2026-02-21_0600_name.md"
  const fnMatch = r.rel_path.match(/(\d{4})-(\d{2})-(\d{2})_(\d{2})(\d{2})/);
  if (fnMatch) {
    const [, y, mo, d, h, mi] = fnMatch;
    const utc = new Date(Date.UTC(+y, +mo - 1, +d, +h, +mi));
    return _formatLocal(utc);
  }
  // Try "**Date**: 2026-02-21 06:00 UTC" in text
  const dateMatch = r.text.match(/\*\*Date\*\*:\s*(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})/);
  if (dateMatch) {
    const [, y, mo, d, h, mi] = dateMatch;
    const utc = new Date(Date.UTC(+y, +mo - 1, +d, +h, +mi));
    return _formatLocal(utc);
  }
  // Try "### User (06:00 UTC)" - no full date, show time only
  const tsMatch = r.text.match(/###\s+\w+\s+\((\d{2}):(\d{2})\s*UTC\)/);
  if (tsMatch) {
    const now = new Date();
    const utc = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), +tsMatch[1], +tsMatch[2]));
    return `${String(utc.getHours()).padStart(2, '0')}:${String(utc.getMinutes()).padStart(2, '0')}`;
  }
  return '';
}

function renderNotes(results) {
  notesGrid.innerHTML = '';
  if (!results.length) {
    notesSection.classList.remove('visible');
    return;
  }
  notesHeader.textContent = `Notes (${results.length})`;
  for (const r of results) {
    const card = document.createElement('div');
    card.className = 'note-card';
    const pathLabel = r.rel_path.split('/').slice(-2).join('/');
    const noteDate = extractNoteDate(r);
    card.innerHTML =
      '<div class="note-card-header">' +
        '<span class="note-card-path">' + escapeHtml(pathLabel) + ' :' + r.start_line + '-' + r.end_line + '</span>' +
        '<span class="note-card-score">' + r.score.toFixed(3) + '</span>' +
      '</div>' +
      (noteDate ? '<div class="note-card-date">' + escapeHtml(noteDate) + '</div>' : '') +
      '<div class="note-card-text">' + escapeHtml(r.text) + '</div>';
    card.onclick = () => {
      if (!optPhotos.checked) {
        const wasExpanded = card.classList.contains('expanded');
        notesGrid.querySelectorAll('.note-card.expanded').forEach(c => c.classList.remove('expanded'));
        notesGrid.querySelectorAll('.note-card.active').forEach(c => c.classList.remove('active'));
        if (!wasExpanded) {
          card.classList.add('expanded');
          card.classList.add('active');
        }
      } else {
        enterNoteFocus(r, card);
      }
    };
    card.ondblclick = () => openNoteReader(r);
    notesGrid.appendChild(card);
  }
  notesSection.classList.add('visible');
}

const contentArea = document.querySelector('.content-area');
const noteReader = document.getElementById('noteReader');
const noteReaderPath = document.getElementById('noteReaderPath');
const noteReaderText = document.getElementById('noteReaderText');
let _savedQuery = '';

function enterNoteFocus(note, cardEl) {
  // Highlight the active card
  notesGrid.querySelectorAll('.note-card.active').forEach(c => c.classList.remove('active'));
  cardEl.classList.add('active');

  // Expand the card text inline
  notesGrid.querySelectorAll('.note-card.expanded').forEach(c => c.classList.remove('expanded'));
  cardEl.classList.add('expanded');

  // Save current query so we can restore on exit
  if (!contentArea.classList.contains('note-focus')) {
    _savedQuery = queryInput.value;
  }

  // Enter note-focus layout
  contentArea.classList.add('note-focus');

  // Search photos using the note text
  const hdrs = { 'Content-Type': 'application/json' };
  fetch('/search-stream', {
    method: 'POST', headers: hdrs,
    body: JSON.stringify({ query: note.text.trim(), score_ratio: parseInt(document.getElementById('scoreThreshold').value, 10) / 100 }),
  }).then(async resp => {
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let idx;
      while ((idx = buffer.indexOf('\n\n')) >= 0) {
        const chunk = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);
        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = JSON.parse(line.slice(6));
          _allResults = data;
          _lastResults = data;
          _displayedCount = 0;
          clearResultsGrid();
          if (data.length) {
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.id = 'resultsGrid';
            resultsDiv.appendChild(grid);
            showMore();
          }
        }
      }
    }
  }).catch(() => {});
}

function exitNoteFocus() {
  contentArea.classList.remove('note-focus');
  contentArea.classList.remove('notes-only');
  notesGrid.querySelectorAll('.note-card.active').forEach(c => c.classList.remove('active'));
  notesGrid.querySelectorAll('.note-card.expanded').forEach(c => c.classList.remove('expanded'));
  if (_savedQuery) {
    queryInput.value = _savedQuery;
    _savedQuery = '';
    doSearch();
  }
}

function openNoteReader(note) {
  const pathLabel = note.rel_path.split('/').slice(-2).join('/');
  noteReaderPath.textContent = pathLabel + ' :' + note.start_line + '-' + note.end_line;
  noteReaderText.textContent = note.text;
  noteReader.classList.add('active');
}

function closeNoteReader(e) {
  if (e && e.target !== noteReader && !e.target.classList.contains('note-reader-close')) return;
  noteReader.classList.remove('active');
}

function clearResultsGrid() {
  const grid = document.getElementById('resultsGrid');
  if (grid) grid.remove();
  resultsDiv.querySelectorAll('.empty-state').forEach(el => el.remove());
}

async function doSearch() {
  const query = queryInput.value.trim();
  if (!query) return;

  // Exit similar/person mode if active
  document.getElementById('similarBar').classList.remove('visible');
  _similarPrevResults = null;
  _similarPrevQuery = '';
  personBar.classList.remove('visible');
  _personMode = false;
  _personPrevResults = null;
  _personPrevQuery = '';
  _personChecked.clear();

  pushHistory(query);
  searchBtn.disabled = true;
  searchMeta.innerHTML = '<span class="spinner"></span>Searching...';
  _allResults = [];
  _displayedCount = 0;
  _selectedCardIndex = -1;
  notesSection.classList.remove('visible');
  contentArea.classList.remove('notes-only');

  const hdrs = { 'Content-Type': 'application/json' };
  const t0 = performance.now();

  // Fire thought search independently (if enabled)
  if (optNotes.checked) {
    fetch('/search-thoughts', { method: 'POST', headers: hdrs,
      body: JSON.stringify({ query, top_k: 10 }),
    }).then(r => r.json()).then(renderNotes).catch(() => {});
  } else {
    notesSection.classList.remove('visible');
  }

  if (!optPhotos.checked) {
    clearResultsGrid();
    if (!optNotes.checked) {
      resultsDiv.insertAdjacentHTML('beforeend', '<div class="empty-state"><h2>No search sources selected</h2><p>Enable Photos or Notes in search options</p></div>');
      searchMeta.textContent = '';
    } else {
      searchMeta.textContent = '';
      contentArea.classList.add('notes-only');
    }
    searchBtn.disabled = false;
    return;
  }

  try {
    const resp = await fetch('/search-stream', {
      method: 'POST', headers: hdrs,
      body: JSON.stringify({ query, score_ratio: parseInt(document.getElementById('scoreThreshold').value, 10) / 100 }),
    });

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      let idx;
      while ((idx = buffer.indexOf('\n\n')) >= 0) {
        const chunk = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);

        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = JSON.parse(line.slice(6));
          const elapsed = ((performance.now() - t0) / 1000).toFixed(2);

          _allResults = data;
          _lastResults = data;
          _displayedCount = 0;
          _selectedCardIndex = -1;

          clearResultsGrid();
          if (data.length) {
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.id = 'resultsGrid';
            resultsDiv.appendChild(grid);
            showMore();
          }
          updateSearchMeta(elapsed);
        }
      }
    }

    const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
    if (!_allResults.length) {
      clearResultsGrid();
      resultsDiv.insertAdjacentHTML('beforeend', `
        <div class="empty-state">
          <h2>No matching results</h2>
          <p>Try a different description</p>
        </div>`);
      searchMeta.textContent = `0 results (${elapsed}s)`;
    } else {
      updateSearchMeta(elapsed);
    }
  } catch (e) {
    clearResultsGrid();
    resultsDiv.insertAdjacentHTML('beforeend', `
      <div class="empty-state">
        <h2>Search failed</h2>
        <p>${escapeHtml(e.message)}</p>
      </div>`);
    searchMeta.textContent = 'Error';
  } finally {
    searchBtn.disabled = false;
  }
}

function showMore() {
  const grid = document.getElementById('resultsGrid');
  if (!grid || _displayedCount >= _allResults.length) return;
  const end = Math.min(_displayedCount + PAGE_SIZE, _allResults.length);
  const slice = _allResults.slice(_displayedCount, end);
  appendCards(grid, slice);
  _displayedCount = end;
}

function updateSearchMeta(elapsed) {
  const total = _allResults.length;
  const shown = _displayedCount;
  if (shown < total) {
    searchMeta.textContent = `${shown} of ${total} results` + (elapsed ? ` (${elapsed}s)` : '');
  } else {
    searchMeta.textContent = `${total} results` + (elapsed ? ` (${elapsed}s)` : '');
  }
}

function thumbUrl(previewPath) {
  // preview_thumbnail is like "/path/to/.cache/photo-embed/thumbnails/preview/abc123.webp"
  // extract the filename and serve via /thumbnails/
  const parts = previewPath.split('/');
  return '/thumbnails/' + parts[parts.length - 1];
}

function filename(path) {
  const parts = path.split('/');
  return parts[parts.length - 1];
}

const _MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const _DAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
function formatDate(exifDate) {
  // EXIF format: "2023:07:15 14:30:00" -> "Sat Jul 15, 14:30"
  if (!exifDate) return '';
  const m = exifDate.match(/(\d{4}):(\d{2}):(\d{2})\s+(\d{2}):(\d{2})/);
  if (!m) {
    const parts = exifDate.split(':');
    if (parts.length >= 2) {
      const mon = parseInt(parts[1], 10);
      if (mon >= 1 && mon <= 12) return `${_MONTHS[mon - 1]} ${parts[0]}`;
    }
    return exifDate;
  }
  const dt = new Date(+m[1], +m[2] - 1, +m[3], +m[4], +m[5]);
  const day = _DAYS[dt.getDay()];
  const mon = _MONTHS[dt.getMonth()];
  return `${day} ${mon} ${dt.getDate()}, ${m[4]}:${m[5]}`;
}

function formatDateShort(exifDate) {
  // Compact format for overlay: "Jul 15, 2023"
  if (!exifDate) return '';
  const m = exifDate.match(/(\d{4}):(\d{2}):(\d{2})/);
  if (!m) return '';
  return `${_MONTHS[+m[2] - 1]} ${+m[3]}, ${m[1]}`;
}

function appendCards(grid, results) {
  for (const r of results) {
    const card = document.createElement('div');
    card.className = 'card';
    card.onclick = (e) => { if (!e.target.closest('.card-similar-btn')) openLightbox(r); };

    const scores = Object.entries(r.model_scores)
      .map(([m, s]) => `${m.replace(/-vit.*/, '')}: ${s.toFixed(3)}`)
      .join(' | ');

    const anns = r.annotations || [];
    const hasTasks = anns.some(a => a.startsWith('@task '));
    const hasNotes = anns.length > 0;
    let html = '<div class="card-image-wrap">';
    html += `<button type="button" class="card-similar-btn" data-path="${escapeAttr(r.path)}" data-thumb="${escapeAttr(thumbUrl(r.preview_thumbnail))}">Similar</button>`;
    if (hasNotes) {
      const cls = hasTasks ? 'card-badge has-tasks' : 'card-badge';
      html += `<div class="${cls}"><svg viewBox="0 0 24 24"><path d="M12 20h9M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg></div>`;
      html += '<div class="card-overlay"><div class="card-overlay-scroll">';
      for (const a of anns) {
        const isTask = a.startsWith('@task ');
        html += `<div class="card-overlay-line${isTask ? ' task' : ''}">${escapeHtml(a)}</div>`;
      }
      html += '</div></div>';
    }
    html += `<img class="card-img" src="${thumbUrl(r.preview_thumbnail)}" loading="lazy" alt="">`;
    if (r.date_taken || r.location) {
      html += '<div class="card-meta-overlay">';
      if (r.date_taken) html += `<span class="card-meta-date">${formatDateShort(r.date_taken)}</span>`;
      if (r.location) html += `<span class="card-meta-location">${escapeHtml(r.location)}</span>`;
      html += '</div>';
    }
    html += '</div>';
    html += '<div class="card-info">';
    html += `<div class="card-filename" title="${r.path}">${filename(r.path)}</div>`;
    html += `<div class="card-scores">${scores}</div>`;
    html += '</div>';

    card.innerHTML = html;
    grid.appendChild(card);
  }
}

function openLightbox(result) {
  _lightboxResult = result;
  lightboxImg.src = thumbUrl(result.preview_thumbnail);
  lightboxPath.textContent = result.path;
  const metaParts = [];
  if (result.date_taken) metaParts.push(formatDate(result.date_taken));
  if (result.location) metaParts.push(result.location);
  document.getElementById('lightboxMeta').textContent = metaParts.join(' \u2014 ');
  lightbox.classList.add('active');
  annotationInput.value = '';
  loadAnnotations(result.path);
  loadFaces(result.path);
  if (notesEnabled()) searchNotesForImage(result);
}

function searchNotesForImage(result) {
  // Build a query from the image's annotations and filename
  const anns = (result.annotations || []).filter(a => !a.startsWith('@task '));
  const name = filename(result.path).replace(/\.[^.]+$/, '').replace(/[-_]/g, ' ');
  const query = anns.length ? anns.join(' ') : name;
  const hdrs = { 'Content-Type': 'application/json' };
  fetch('/search-thoughts', { method: 'POST', headers: hdrs,
    body: JSON.stringify({ query, top_k: 10 }),
  }).then(r => r.json()).then(renderNotes).catch(() => {});
}

function closeLightbox(e) {
  if (e && e.target !== lightbox) return;
  lightbox.classList.remove('active');
  lightboxImg.src = '';
  _lightboxResult = null;
  closeFaceMenu();
  document.querySelectorAll('#lightboxWrap .face-box').forEach(b => b.remove());
  _faceData = [];
}

function lightboxFindSimilar() {
  if (!_lightboxResult) return;
  const r = _lightboxResult;
  closeLightbox();
  doFindSimilar(r.path, thumbUrl(r.preview_thumbnail));
}

function renderAnnotationTags(annotations) {
  annotationRow.querySelectorAll('.annotation-tag').forEach(t => t.remove());
  for (const text of annotations) {
    const tag = document.createElement('span');
    tag.className = text.startsWith('@task ') ? 'annotation-tag task' : 'annotation-tag';

    const span = document.createElement('span');
    span.className = 'tag-text';
    span.textContent = text;
    span.onclick = (e) => { e.stopPropagation(); startEditTag(span, text); };

    const x = document.createElement('span');
    x.className = 'remove-tag';
    x.title = 'Remove';
    x.textContent = '\u00d7';
    x.onclick = (e) => { e.stopPropagation(); removeAnnotation(text); };

    tag.appendChild(span);
    tag.appendChild(x);
    annotationRow.insertBefore(tag, annotationInput);
  }
}

function startEditTag(span, originalText) {
  span.contentEditable = 'true';
  span.focus();
  // Select all text
  const range = document.createRange();
  range.selectNodeContents(span);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);

  function commit() {
    span.contentEditable = 'false';
    const newText = span.textContent.trim();
    span.removeEventListener('keydown', onKey);
    span.removeEventListener('blur', onBlur);
    if (!newText || newText === originalText) {
      span.textContent = originalText;
      return;
    }
    editAnnotation(originalText, newText);
  }
  function cancel() {
    span.contentEditable = 'false';
    span.textContent = originalText;
    span.removeEventListener('keydown', onKey);
    span.removeEventListener('blur', onBlur);
  }
  function onKey(e) {
    e.stopPropagation();
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  }
  function onBlur() { commit(); }
  span.addEventListener('keydown', onKey);
  span.addEventListener('blur', onBlur);
}

function escapeHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

async function loadAnnotations(path) {
  try {
    const resp = await fetch('/annotations?path=' + encodeURIComponent(path));
    const annotations = await resp.json();
    renderAnnotationTags(annotations);
  } catch { /* ignore */ }
}

async function addAnnotation(text) {
  if (!_lightboxResult || !text.trim()) return;
  try {
    await fetch('/annotate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: text.trim() }),
    });
    annotationInput.value = '';
    loadAnnotations(_lightboxResult.path);
    // Update the result object so the card shows it too
    if (!_lightboxResult.annotations.includes(text.trim())) {
      _lightboxResult.annotations.push(text.trim());
      updateCardAnnotations(_lightboxResult);
    }
  } catch { /* ignore */ }
}

async function editAnnotation(oldText, newText) {
  if (!_lightboxResult) return;
  try {
    await fetch('/remove-annotation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: oldText }),
    });
    await fetch('/annotate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text: newText }),
    });
    _lightboxResult.annotations = _lightboxResult.annotations.map(a => a === oldText ? newText : a);
    updateCardAnnotations(_lightboxResult);
    loadAnnotations(_lightboxResult.path);
  } catch { /* ignore */ }
}

async function removeAnnotation(text) {
  if (!_lightboxResult) return;
  try {
    await fetch('/remove-annotation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: _lightboxResult.path, text }),
    });
    loadAnnotations(_lightboxResult.path);
    _lightboxResult.annotations = _lightboxResult.annotations.filter(a => a !== text);
    updateCardAnnotations(_lightboxResult);
  } catch { /* ignore */ }
}

function updateCardAnnotations(result, shouldGlow) {
  const cards = document.querySelectorAll('.card');
  for (const card of cards) {
    const fn = card.querySelector('.card-filename');
    if (fn && fn.title === result.path) {
      const wrap = card.querySelector('.card-image-wrap');
      const anns = result.annotations || [];
      const hasTasks = anns.some(a => a.startsWith('@task '));
      let badge = wrap.querySelector('.card-badge');
      let overlay = wrap.querySelector('.card-overlay');

      if (anns.length) {
        // Badge
        if (!badge) {
          badge = document.createElement('div');
          badge.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 20h9M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>';
          wrap.insertBefore(badge, wrap.firstChild);
        }
        badge.className = hasTasks ? 'card-badge has-tasks' : 'card-badge';

        // Overlay
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'card-overlay';
          wrap.insertBefore(overlay, wrap.querySelector('.card-img'));
        }
        let oh = '<div class="card-overlay-scroll">';
        for (const a of anns) {
          const isTask = a.startsWith('@task ');
          oh += `<div class="card-overlay-line${isTask ? ' task' : ''}">${escapeHtml(a)}</div>`;
        }
        oh += '</div>';
        overlay.innerHTML = oh;
      } else {
        if (badge) badge.remove();
        if (overlay) overlay.remove();
      }

      if (shouldGlow) {
        card.classList.remove('glow');
        void card.offsetWidth; // force reflow to restart animation
        card.classList.add('glow');
        setTimeout(() => card.classList.remove('glow'), 1600);
      }
      break;
    }
  }
}

// --- Find Similar mode ---

let _similarPrevResults = null;
let _similarPrevQuery = '';

resultsDiv.addEventListener('click', (e) => {
  const btn = e.target.closest('.card-similar-btn');
  if (!btn) return;
  e.stopPropagation();
  doFindSimilar(btn.dataset.path, btn.dataset.thumb);
});

async function doFindSimilar(path, thumbSrc) {
  // Save current state for back navigation
  if (!_similarPrevResults) {
    _similarPrevResults = _allResults;
    _similarPrevQuery = queryInput.value;
  }

  const similarBar = document.getElementById('similarBar');
  document.getElementById('similarThumb').src = thumbSrc;
  document.getElementById('similarName').textContent = filename(path);
  similarBar.classList.add('visible');

  searchBtn.disabled = true;
  searchMeta.innerHTML = '<span class="spinner"></span>Finding similar...';

  try {
    const resp = await fetch('/find-similar', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path, score_ratio: parseInt(document.getElementById('scoreThreshold').value, 10) / 100 }),
    });
    const data = await resp.json();
    _allResults = data;
    _lastResults = data;
    _displayedCount = 0;
    _selectedCardIndex = -1;

    // Clear grid but keep the similar bar
    const existing = document.getElementById('resultsGrid');
    if (existing) existing.remove();
    resultsDiv.querySelectorAll('.empty-state').forEach(el => el.remove());

    if (data.length) {
      const grid = document.createElement('div');
      grid.className = 'grid';
      grid.id = 'resultsGrid';
      resultsDiv.appendChild(grid);
      showMore();
    } else {
      resultsDiv.insertAdjacentHTML('beforeend',
        '<div class="empty-state"><h2>No similar images found</h2></div>');
    }
    searchMeta.textContent = `${data.length} similar`;
  } catch (err) {
    searchMeta.textContent = 'Error';
  } finally {
    searchBtn.disabled = false;
  }
}

function exitSimilarMode() {
  document.getElementById('similarBar').classList.remove('visible');
  if (_similarPrevResults) {
    _allResults = _similarPrevResults;
    _lastResults = _similarPrevResults;
    _displayedCount = 0;
    _selectedCardIndex = -1;
    queryInput.value = _similarPrevQuery;
    _similarPrevResults = null;
    _similarPrevQuery = '';

    const existing = document.getElementById('resultsGrid');
    if (existing) existing.remove();
    resultsDiv.querySelectorAll('.empty-state').forEach(el => el.remove());

    if (_allResults.length) {
      const grid = document.createElement('div');
      grid.className = 'grid';
      grid.id = 'resultsGrid';
      resultsDiv.appendChild(grid);
      showMore();
      updateSearchMeta(null);
    }
  }
}

// --- Face overlay & person mode ---

const faceMenu = document.getElementById('faceMenu');
const faceMenuName = document.getElementById('faceMenuName');
const faceMenuLabel = document.getElementById('faceMenuLabel');
const faceMenuFind = document.getElementById('faceMenuFind');
const personBar = document.getElementById('personBar');
const personNameInput = document.getElementById('personNameInput');
const personCount = document.getElementById('personCount');
const personConfirmBtn = document.getElementById('personConfirmBtn');
let _faceData = [];       // face records for current lightbox image
let _activeFace = null;   // { face_idx, image_path } of clicked face
let _personMode = false;
let _personPrevResults = null;
let _personPrevQuery = '';
let _personSourcePath = '';
let _personSourceFaceIdx = 0;
let _personChecked = new Set(); // indices into _allResults that are checked

function closeFaceMenu() {
  faceMenu.classList.remove('visible');
  _activeFace = null;
}

async function loadFaces(path) {
  // Remove existing face boxes
  document.querySelectorAll('#lightboxWrap .face-box').forEach(b => b.remove());
  closeFaceMenu();
  _faceData = [];
  try {
    const resp = await fetch('/faces?path=' + encodeURIComponent(path));
    _faceData = await resp.json();
  } catch { return; }
  if (!_faceData.length) return;

  // Wait for image to have dimensions
  const img = lightboxImg;
  if (!img.naturalWidth) await new Promise(r => img.onload = r);
  renderFaceBoxes();
}

function renderFaceBoxes() {
  document.querySelectorAll('#lightboxWrap .face-box').forEach(b => b.remove());
  const img = lightboxImg;
  const wrap = document.getElementById('lightboxWrap');
  const imgW = img.clientWidth;
  const imgH = img.clientHeight;
  if (!imgW || !imgH) return;

  for (const face of _faceData) {
    const [x1, y1, x2, y2] = face.bbox;
    const box = document.createElement('div');
    box.className = 'face-box' + (face.label ? ' labeled' : '');
    box.style.left = (x1 * imgW) + 'px';
    box.style.top = (y1 * imgH) + 'px';
    box.style.width = ((x2 - x1) * imgW) + 'px';
    box.style.height = ((y2 - y1) * imgH) + 'px';
    if (face.label) {
      box.innerHTML = '<span class="face-label">' + escapeHtml(face.label) + '</span>';
    }
    box.onclick = (e) => {
      e.stopPropagation();
      openFaceMenu(face, box);
    };
    wrap.appendChild(box);
  }
}

function openFaceMenu(face, boxEl) {
  _activeFace = face;
  faceMenuName.value = face.label || '';

  // Position menu near the face box
  const wrap = document.getElementById('lightboxWrap');
  const wrapRect = wrap.getBoundingClientRect();
  const boxRect = boxEl.getBoundingClientRect();

  let left = boxRect.right - wrapRect.left + 6;
  let top = boxRect.top - wrapRect.top;

  // Keep menu inside viewport
  faceMenu.classList.add('visible');
  const menuRect = faceMenu.getBoundingClientRect();
  if (left + menuRect.width > wrapRect.width) {
    left = boxRect.left - wrapRect.left - menuRect.width - 6;
  }
  if (top + menuRect.height > wrapRect.height) {
    top = wrapRect.height - menuRect.height - 4;
  }
  if (top < 0) top = 4;

  faceMenu.style.left = left + 'px';
  faceMenu.style.top = top + 'px';
  faceMenuName.focus();
}

faceMenuName.addEventListener('keydown', (e) => {
  e.stopPropagation();
  if (e.key === 'Enter') {
    e.preventDefault();
    doLabelFace();
  }
  if (e.key === 'Escape') {
    e.preventDefault();
    closeFaceMenu();
  }
});

faceMenuLabel.addEventListener('click', (e) => {
  e.stopPropagation();
  doLabelFace();
});

faceMenuFind.addEventListener('click', (e) => {
  e.stopPropagation();
  doFindPerson();
});

async function doLabelFace() {
  if (!_activeFace || !_lightboxResult) return;
  const name = faceMenuName.value.trim();
  if (!name) { faceMenuName.focus(); return; }

  try {
    await fetch('/label-face', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        path: _lightboxResult.path,
        face_idx: _activeFace.face_idx,
        label: name,
      }),
    });
    // Refresh face data and annotations
    closeFaceMenu();
    loadFaces(_lightboxResult.path);
    loadAnnotations(_lightboxResult.path);
  } catch { /* ignore */ }
}

async function doFindPerson() {
  if (!_activeFace || !_lightboxResult) return;
  const face = _activeFace;
  const result = _lightboxResult;
  const name = faceMenuName.value.trim();

  closeFaceMenu();
  closeLightbox();

  // Save state for back nav
  if (!_personPrevResults) {
    _personPrevResults = _allResults;
    _personPrevQuery = queryInput.value;
  }

  _personMode = true;
  _personSourcePath = result.path;
  _personSourceFaceIdx = face.face_idx;

  // Show person bar
  document.getElementById('personThumb').src = thumbUrl(result.preview_thumbnail);
  personNameInput.value = name || face.label || '';
  personBar.classList.add('visible');
  document.getElementById('similarBar').classList.remove('visible');

  searchBtn.disabled = true;
  searchMeta.innerHTML = '<span class="spinner"></span>Finding person...';

  try {
    const resp = await fetch('/find-person', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        path: result.path,
        face_idx: face.face_idx,
      }),
    });
    const data = await resp.json();
    _allResults = data;
    _lastResults = data;
    _displayedCount = 0;
    _selectedCardIndex = -1;
    _personChecked = new Set(data.map((_, i) => i)); // all checked by default

    clearResultsGrid();
    if (data.length) {
      const grid = document.createElement('div');
      grid.className = 'grid';
      grid.id = 'resultsGrid';
      resultsDiv.appendChild(grid);
      showMore();
      addPersonCheckboxes();
      updatePersonCount();
    } else {
      resultsDiv.insertAdjacentHTML('beforeend',
        '<div class="empty-state"><h2>No matching faces found</h2><p>Try running face detection first (refresh faces)</p></div>');
    }
    searchMeta.textContent = `${data.length} matches`;
  } catch (err) {
    searchMeta.textContent = 'Error';
  } finally {
    searchBtn.disabled = false;
  }
}

function addPersonCheckboxes() {
  const cards = getCards();
  cards.forEach((card, i) => {
    const existing = card.querySelector('.card-check');
    if (existing) existing.remove();

    const wrap = card.querySelector('.card-image-wrap');
    const check = document.createElement('div');
    check.className = 'card-check' + (_personChecked.has(i) ? ' checked' : '');
    check.innerHTML = '<svg viewBox="0 0 14 14"><polyline points="2.5 7 5.5 10.5 11.5 3.5"/></svg>';
    check.onclick = (e) => {
      e.stopPropagation();
      if (_personChecked.has(i)) {
        _personChecked.delete(i);
        check.classList.remove('checked');
      } else {
        _personChecked.add(i);
        check.classList.add('checked');
      }
      updatePersonCount();
    };
    // Hide the Similar button in person mode
    const simBtn = card.querySelector('.card-similar-btn');
    if (simBtn) simBtn.style.display = 'none';
    wrap.insertBefore(check, wrap.firstChild);
  });
}

function updatePersonCount() {
  personCount.textContent = _personChecked.size + ' of ' + _allResults.length + ' selected';
  personConfirmBtn.disabled = !_personChecked.size || !personNameInput.value.trim();
}

personNameInput.addEventListener('input', updatePersonCount);
personNameInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    confirmPersonLabels();
  }
});

async function confirmPersonLabels() {
  const name = personNameInput.value.trim();
  if (!name || !_personChecked.size) return;

  personConfirmBtn.disabled = true;
  personConfirmBtn.textContent = 'Labeling...';

  // Build matches from checked results  face_idx comes from find_person response
  const matches = [];
  for (const i of _personChecked) {
    const r = _allResults[i];
    matches.push({
      image_path: r.path,
      face_idx: r.face_idx >= 0 ? r.face_idx : 0,
    });
  }

  if (matches.length) {
    try {
      await fetch('/batch-label', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ matches, label: name }),
      });
    } catch { /* ignore */ }
  }

  personConfirmBtn.textContent = 'Confirm selected';
  personConfirmBtn.disabled = false;
  exitPersonMode();
}

function exitPersonMode() {
  _personMode = false;
  personBar.classList.remove('visible');
  _personChecked.clear();

  if (_personPrevResults) {
    _allResults = _personPrevResults;
    _lastResults = _personPrevResults;
    _displayedCount = 0;
    _selectedCardIndex = -1;
    queryInput.value = _personPrevQuery;
    _personPrevResults = null;
    _personPrevQuery = '';

    clearResultsGrid();
    if (_allResults.length) {
      const grid = document.createElement('div');
      grid.className = 'grid';
      grid.id = 'resultsGrid';
      resultsDiv.appendChild(grid);
      showMore();
      updateSearchMeta(null);
    }
  }
}

// Re-add checkboxes when showMore loads additional cards in person mode
const _origShowMore = showMore;

// Observe new cards added to resultsGrid for person mode
const _showMoreObserver = new MutationObserver(() => {
  if (_personMode) {
    addPersonCheckboxes();
  }
});

// Start observing when a grid is created (patched into showMore flow)
// We'll use a simpler approach: override showMore
showMore = function() {
  _origShowMore();
  if (_personMode) {
    addPersonCheckboxes();
  }
};

// Close face menu when clicking elsewhere in lightbox
document.getElementById('lightboxWrap').addEventListener('click', (e) => {
  if (!e.target.closest('.face-menu') && !e.target.closest('.face-box')) {
    closeFaceMenu();
  }
});

// Reposition face boxes on window resize
window.addEventListener('resize', () => {
  if (lightbox.classList.contains('active') && _faceData.length) {
    renderFaceBoxes();
  }
});

annotationInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.stopPropagation();
    addAnnotation(annotationInput.value);
  }
  if (e.key === 'Escape') {
    e.stopPropagation();
    closeLightbox();
  }
});

// --- Task polling (detect resolved tasks, trigger glow) ---

let _lastResults = []; // current search results for task polling

async function pollTasks() {
  if (!_lastResults.length) return;
  // Only poll cards that have tasks
  const taskResults = _lastResults.filter(r => r.annotations && r.annotations.some(a => a.startsWith('@task ')));
  for (const r of taskResults) {
    try {
      const resp = await fetch('/annotations?path=' + encodeURIComponent(r.path));
      const fresh = await resp.json();
      const oldTasks = r.annotations.filter(a => a.startsWith('@task '));
      const newTasks = fresh.filter(a => a.startsWith('@task '));
      if (newTasks.length < oldTasks.length) {
        // A task was resolved
        r.annotations = fresh;
        updateCardAnnotations(r, true);
        // Update lightbox if open on this image
        if (_lightboxResult && _lightboxResult.path === r.path) {
          _lightboxResult.annotations = fresh;
          renderAnnotationTags(fresh);
        }
      } else if (JSON.stringify(r.annotations.sort()) !== JSON.stringify(fresh.sort())) {
        r.annotations = fresh;
        updateCardAnnotations(r, false);
      }
    } catch { /* ignore */ }
  }
}

setInterval(pollTasks, 3000);

// --- Status panel ---

const statusPanel = document.getElementById('statusPanel');
const statusDot = document.getElementById('statusDot');
const statusSummary = document.getElementById('statusSummary');
const statImages = document.getElementById('statImages');
const statChunks = document.getElementById('statChunks');
const statModels = document.getElementById('statModels');
const statFolders = document.getElementById('statFolders');
const statFaces = document.getElementById('statFaces');
const statCache = document.getElementById('statCache');
const statActivity = document.getElementById('statActivity');
const refreshBtn = document.getElementById('refreshBtn');

function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
}

let _refreshing = false;

function togglePanel() {
  statusPanel.classList.toggle('collapsed');
}

function folderName(path) {
  const parts = path.split('/');
  return parts[parts.length - 1] || parts[parts.length - 2];
}

async function pollStatus() {
  try {
    const promises = [fetch('/status')];
    if (notesEnabled()) promises.push(fetch('/thought-status').catch(() => null));
    const [resp, thoughtResp = null] = await Promise.all(promises);
    const s = await resp.json();
    const ts = thoughtResp ? await thoughtResp.json().catch(() => ({})) : {};
    const n = s.total_images || 0;
    const chunks = ts.total_chunks || 0;
    statChunks.textContent = chunks.toLocaleString();
    const models = (s.enabled_models || []).map(m => m.replace(/-vit.*/, '')).join(', ');
    const folders = (s.folders || []).map(folderName);
    if (s.photos_library) folders.push('Photos Library');

    const faces = s.total_faces || 0;
    statImages.textContent = n.toLocaleString();
    statFaces.textContent = faces.toLocaleString();
    document.getElementById('statFacesWrap').style.display = faces > 0 ? '' : 'none';
    statCache.textContent = s.cache_size_bytes != null ? formatBytes(s.cache_size_bytes) : '--';
    if (s.cache_dir) document.getElementById('statCacheWrap').title = s.cache_dir;
    statModels.textContent = models || '--';
    const fullPaths = [...(s.folders || [])];
    if (s.photos_library) fullPaths.push(s.photos_library);
    const folderDisplay = folders.length ? folders.join(', ') : 'No folders';
    statFolders.innerHTML = '<span class="folder-label">' + escapeHtml(folderDisplay) + '</span>'
      + (fullPaths.length ? '<div class="folder-tooltip">' + fullPaths.map(p => '<div>' + escapeHtml(p) + '</div>').join('') + '</div>' : '');

    const act = s.activity;
    if (act) {
      statusDot.classList.add('busy');
      const p = act.progress;
      if (p && p.total > 0) {
        const pct = Math.round(100 * p.current / p.total);
        const rate = p.detail || '';
        statusSummary.textContent = `${p.current.toLocaleString()} of ${p.total.toLocaleString()} images (${pct}%)`;
        statActivity.textContent = rate ? `${act.operation}  ${rate}` : act.operation;
      } else {
        statusSummary.textContent = `${n.toLocaleString()} images  ${act.operation}...`;
        statActivity.textContent = act.operation;
      }
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'Busy';
    } else if (_refreshing) {
      statusDot.classList.add('busy');
      statusSummary.textContent = `${n.toLocaleString()} images  refreshing...`;
    } else {
      statusDot.classList.remove('busy');
      statusSummary.textContent = faces > 0
        ? `${n.toLocaleString()} images, ${faces.toLocaleString()} faces`
        : `${n.toLocaleString()} images`;
      statActivity.textContent = '';
      refreshBtn.disabled = false;
      refreshBtn.textContent = 'Refresh';
    }
  } catch {
    statusDot.classList.remove('busy');
    statusSummary.textContent = 'Service unavailable';
  }
}

async function doPickFolder() {
  const btn = document.getElementById('addFolderBtn');
  btn.disabled = true;
  btn.textContent = 'Selecting...';
  try {
    const resp = await fetch('/pick-folder', { method: 'POST' });
    const msg = await resp.text();
    statActivity.textContent = msg;
    setTimeout(() => { if (statActivity.textContent === msg) statActivity.textContent = ''; }, 5000);
    pollStatus();
  } catch {
    statActivity.textContent = 'Picker failed';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Add Folder';
  }
}

async function doRefresh() {
  if (_refreshing) return;
  _refreshing = true;
  refreshBtn.disabled = true;
  refreshBtn.textContent = 'Refreshing...';
  statActivity.textContent = 'Scanning for new photos...';
  statusDot.classList.add('busy');

  try {
    // Refresh photos + notes in parallel
    const thoughtPromise = notesEnabled()
      ? fetch('/search-thoughts-reindex', { method: 'POST' }).catch(() => null)
      : Promise.resolve(null);

    const photoResp = await fetch('/refresh', { method: 'POST' });
    const stats = await photoResp.json();
    const parts = [];
    if (stats.new) parts.push(`+${stats.new} new`);
    if (stats.changed) parts.push(`~${stats.changed} changed`);
    if (stats.deleted) parts.push(`-${stats.deleted} deleted`);

    const thoughtResp = await thoughtPromise;
    if (thoughtResp) {
      const ts = await thoughtResp.json().catch(() => null);
      if (ts && ts.total_chunks != null) {
        parts.push(`${ts.total_chunks} notes`);
      }
    }

    statActivity.textContent = parts.length
      ? parts.join(', ')
      : 'Up to date';
    setTimeout(() => { if (!_refreshing) statActivity.textContent = ''; }, 5000);

    // Fire face detection in background  progress shows in status bar via pollStatus
    fetch('/refresh-faces', { method: 'POST' }).catch(() => {});
  } catch (e) {
    statActivity.textContent = 'Refresh failed';
  } finally {
    _refreshing = false;
    refreshBtn.disabled = false;
    refreshBtn.textContent = 'Refresh';
    pollStatus();
  }
}

applyNotesVisibility();
pollStatus();
setInterval(pollStatus, 5000);

// ---- Entity Panel ----

let _entitySearchTimer = null;
let _entityMergeSet = new Set();
let _entityData = [];
let _selectedEntityId = null;
let _mergeMode = false;

function openEntityPanel() {
  document.getElementById('entityPanel').classList.add('open');
  loadEntityStats();
  loadEntities();
}

function closeEntityPanel(e) {
  if (e && e.target !== document.getElementById('entityPanel')) return;
  document.getElementById('entityPanel').classList.remove('open');
  cancelEntityMerge();
  _selectedEntityId = null;
  document.getElementById('entityDetail').style.display = 'none';
}

function entitySearchDebounce() {
  clearTimeout(_entitySearchTimer);
  _entitySearchTimer = setTimeout(loadEntities, 300);
}

async function loadEntityStats() {
  try {
    const resp = await fetch('/entity-stats');
    const s = await resp.json();
    const bar = document.getElementById('entityStatsBar');
    const parts = [];
    if (s.total_entities) parts.push(`${s.total_entities} entities`);
    if (s.total_mentions) parts.push(`${s.total_mentions} mentions`);
    const byType = s.by_type || {};
    for (const [t, c] of Object.entries(byType)) {
      parts.push(`${c} ${t}s`);
    }
    bar.textContent = parts.join(' \u00b7 ') || 'No entities yet. Run Refresh to extract.';
  } catch {
    document.getElementById('entityStatsBar').textContent = 'Stats unavailable';
  }
}

async function loadEntities() {
  const query = document.getElementById('entitySearchInput').value.trim();
  const type = document.getElementById('entityTypeFilter').value;
  const listEl = document.getElementById('entityList');

  try {
    let entities;
    if (query) {
      const resp = await fetch('/search-entities', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({query, type: type || undefined, limit: 100}),
      });
      entities = await resp.json();
    } else {
      const params = new URLSearchParams();
      if (type) params.set('type', type);
      params.set('limit', '100');
      const resp = await fetch('/entities?' + params);
      entities = await resp.json();
    }
    _entityData = entities;
    renderEntityList(entities);
  } catch {
    listEl.innerHTML = '<div style="padding:1rem;color:var(--text-dim)">Failed to load entities</div>';
  }
}

function renderEntityList(entities) {
  const listEl = document.getElementById('entityList');
  if (!entities.length) {
    listEl.innerHTML = '<div style="padding:1rem;color:var(--text-dim)">No entities found</div>';
    return;
  }
  listEl.innerHTML = entities.map(e => {
    const selected = _selectedEntityId === e.id ? ' selected' : '';
    const checked = _entityMergeSet.has(e.id) ? ' checked' : '';
    const checkbox = _mergeMode
      ? `<input type="checkbox" ${checked} onclick="event.stopPropagation(); toggleMergeSelect(${e.id})">`
      : '';
    const aliases = (e.aliases && e.aliases.length)
      ? `<span class="entity-aliases">${escapeHtml(e.aliases.join(', '))}</span>`
      : '';
    return `<div class="entity-item${selected}" onclick="selectEntity(${e.id})">
      ${checkbox}
      <span class="entity-name">${escapeHtml(e.canonical_name)}</span>
      ${aliases}
      <span class="entity-type ${e.type}">${e.type}</span>
      <span class="entity-count">${e.mention_count}</span>
    </div>`;
  }).join('');
}

async function selectEntity(id) {
  _selectedEntityId = id;
  renderEntityList(_entityData);
  const detailEl = document.getElementById('entityDetail');
  detailEl.style.display = '';
  detailEl.innerHTML = '<div style="padding:0.5rem;color:var(--text-dim)">Loading...</div>';

  try {
    const resp = await fetch('/entity?id=' + id);
    const e = await resp.json();
    if (e.error) {
      detailEl.innerHTML = `<div style="color:#f85149">${escapeHtml(e.error)}</div>`;
      return;
    }
    const aliasText = (e.aliases && e.aliases.length)
      ? `<div style="color:var(--text-dim);font-size:0.75rem;margin-bottom:0.4rem">aka: ${escapeHtml(e.aliases.join(', '))}</div>`
      : '';
    const mentions = (e.mentions || []).map(m => {
      const path = m.rel_path || '';
      const ctx = m.context ? escapeHtml(m.context).replace(
        new RegExp('(' + escapeRegExp(m.span_text || e.canonical_name) + ')', 'gi'),
        '<strong style="color:var(--text)">$1</strong>'
      ) : '';
      return `<div class="entity-mention">
        <div class="entity-mention-path">${escapeHtml(path)}${m.start_line ? ':' + m.start_line : ''}</div>
        ${ctx ? '<div class="entity-mention-context">' + ctx + '</div>' : ''}
      </div>`;
    }).join('');

    detailEl.innerHTML = `
      <div class="entity-detail-header">
        <h3>${escapeHtml(e.canonical_name)}</h3>
        <span class="entity-type ${e.type}">${e.type}</span>
        <span style="color:var(--text-dim);font-size:0.75rem">${e.mention_count} mentions</span>
      </div>
      ${aliasText}
      <div class="entity-detail-actions">
        <button onclick="startRenameEntity(${e.id}, '${escapeHtml(e.canonical_name).replace(/'/g, "\\'")}')">Rename</button>
        <button onclick="startMergeMode()">Merge</button>
        <button class="danger" onclick="deleteEntity(${e.id}, '${escapeHtml(e.canonical_name).replace(/'/g, "\\'")}')">Delete</button>
      </div>
      ${mentions || '<div style="color:var(--text-dim);font-size:0.8rem">No mentions recorded</div>'}
    `;
  } catch {
    detailEl.innerHTML = '<div style="color:#f85149">Failed to load entity</div>';
  }
}

function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function startRenameEntity(id, currentName) {
  const newName = prompt('New name for "' + currentName + '":', currentName);
  if (!newName || newName === currentName) return;
  fetch('/rename-entity', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({entity_id: id, new_name: newName}),
  }).then(r => r.json()).then(result => {
    if (result.error) { alert(result.error); return; }
    loadEntities();
    loadEntityStats();
    selectEntity(id);
  });
}

async function deleteEntity(id, name) {
  if (!confirm('Delete entity "' + name + '" and all its mentions?')) return;
  await fetch('/delete-entity', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({entity_id: id}),
  });
  _selectedEntityId = null;
  document.getElementById('entityDetail').style.display = 'none';
  loadEntities();
  loadEntityStats();
}

function startMergeMode() {
  _mergeMode = true;
  _entityMergeSet.clear();
  if (_selectedEntityId) _entityMergeSet.add(_selectedEntityId);
  updateMergeBar();
  renderEntityList(_entityData);
}

function cancelEntityMerge() {
  _mergeMode = false;
  _entityMergeSet.clear();
  document.getElementById('entityMergeBar').classList.remove('active');
  renderEntityList(_entityData);
}

function toggleMergeSelect(id) {
  if (_entityMergeSet.has(id)) {
    _entityMergeSet.delete(id);
  } else {
    _entityMergeSet.add(id);
  }
  updateMergeBar();
  renderEntityList(_entityData);
}

function updateMergeBar() {
  const bar = document.getElementById('entityMergeBar');
  const info = document.getElementById('entityMergeInfo');
  if (!_mergeMode) { bar.classList.remove('active'); return; }
  bar.classList.add('active');
  const n = _entityMergeSet.size;
  if (n < 2) {
    info.textContent = `Select ${2 - n} more entity to merge`;
  } else {
    const names = _entityData
      .filter(e => _entityMergeSet.has(e.id))
      .map(e => e.canonical_name);
    info.textContent = `Merge: ${names.join(' + ')}`;
  }
}

async function doMergeEntities() {
  if (_entityMergeSet.size !== 2) {
    alert('Select exactly 2 entities to merge.');
    return;
  }
  const ids = [..._entityMergeSet];
  const entities = ids.map(id => _entityData.find(e => e.id === id)).filter(Boolean);
  const keepIdx = confirm(
    `Keep "${entities[0].canonical_name}" as the primary name?\n\nOK = keep "${entities[0].canonical_name}"\nCancel = keep "${entities[1].canonical_name}"`
  ) ? 0 : 1;
  const keepId = ids[keepIdx];
  const mergeId = ids[1 - keepIdx];

  try {
    const resp = await fetch('/merge-entities', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({keep_id: keepId, merge_id: mergeId}),
    });
    const result = await resp.json();
    if (result.error) { alert(result.error); return; }
    cancelEntityMerge();
    _selectedEntityId = keepId;
    loadEntities();
    loadEntityStats();
    selectEntity(keepId);
  } catch {
    alert('Merge failed');
  }
}

// Infinite scroll
window.addEventListener('scroll', () => {
  if (_loadingMore || _displayedCount >= _allResults.length) return;
  const scrollBottom = window.innerHeight + window.scrollY;
  if (scrollBottom >= document.body.offsetHeight - 400) {
    _loadingMore = true;
    showMore();
    updateSearchMeta(null);
    _loadingMore = false;
  }
});
</script>
</body>
</html>
